From a78ac68ff49c14c9ee74782978517e8afc55d942 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Marek=20Beh=C3=BAn?= <marek.behun@nic.cz>
Date: Tue, 5 May 2020 20:08:08 +0200
Subject: [PATCH] net: dsa: mv88e6xxx: support multi-CPU DSA
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Add support for multi-CPU DSA for mv88e6xxx.
Currently only works with multiple CPUs when there is only one switch in
the switch tree.

Signed-off-by: Marek Beh√∫n <marek.behun@nic.cz>
---
--- a/drivers/net/dsa/mv88e6xxx/chip.c
+++ b/drivers/net/dsa/mv88e6xxx/chip.c
@@ -1205,6 +1205,7 @@ static u16 mv88e6xxx_port_vlan(struct mv
 	struct net_device *br;
 	struct dsa_port *dp;
 	bool found = false;
+	u8 upstream;
 	u16 pvlan;
 
 	list_for_each_entry(dp, &dst->ports, list) {
@@ -1219,18 +1220,38 @@ static u16 mv88e6xxx_port_vlan(struct mv
 		return 0;
 
 	/* Frames from DSA links and CPU ports can egress any local port */
-	if (dp->type == DSA_PORT_TYPE_CPU || dp->type == DSA_PORT_TYPE_DSA)
+	if (dp->type == DSA_PORT_TYPE_DSA)
 		return mv88e6xxx_port_mask(chip);
 
+	if (dp->type == DSA_PORT_TYPE_CPU) {
+		u16 pmask = mv88e6xxx_port_mask(chip);
+		pvlan = 0;
+		int i;
+
+		for (i = 0; i < mv88e6xxx_num_ports(chip); ++i) {
+			if (dsa_is_cpu_port(ds, i)) {
+				if (i == port)
+					pvlan |= BIT(i);
+				continue;
+			}
+			if ((pmask & BIT(i)) &&
+				dsa_upstream_port(chip->ds, i) == port)
+					pvlan |= BIT(i);
+			}
+
+			return pvlan;
+	}
+
 	br = dp->bridge_dev;
 	pvlan = 0;
 
 	/* Frames from user ports can egress any local DSA links and CPU ports,
 	 * as well as any local member of their bridge group.
 	 */
+	upstream = dsa_upstream_port(chip->ds, port);
 	list_for_each_entry(dp, &dst->ports, list)
 		if (dp->ds == ds &&
-		    (dp->type == DSA_PORT_TYPE_CPU ||
+		    ((dp->type == DSA_PORT_TYPE_CPU && dp->index == upstream) ||
 		     dp->type == DSA_PORT_TYPE_DSA ||
 		     (br && dp->bridge_dev == br)))
 			pvlan |= BIT(dp->index);
@@ -2544,6 +2565,7 @@ static int mv88e6xxx_setup_upstream_port
 	}
 
 	if (port == upstream_port) {
+		dev_info(chip->dev, "Setting CPU port as port %i\n", port);
 		if (chip->info->ops->set_cpu_port) {
 			err = chip->info->ops->set_cpu_port(chip,
 							    upstream_port);
@@ -2569,6 +2591,28 @@ static int mv88e6xxx_setup_upstream_port
 	return 0;
 }
 
+static int mv88e6xxx_port_change_cpu_port(struct dsa_switch *ds, int port,
+                                          struct dsa_port *new_cpu_dp)
+{
+	struct mv88e6xxx_chip *chip = ds->priv;
+	int err;
+
+	mv88e6xxx_reg_lock(chip);
+
+	err = mv88e6xxx_setup_upstream_port(chip, port);
+	if (err)
+		goto unlock;
+
+	err = mv88e6xxx_port_vlan_map(chip, port);
+	if (err)
+		goto unlock;
+
+unlock:
+	mv88e6xxx_reg_unlock(chip);
+
+	return err;
+}
+
 static int mv88e6xxx_setup_port(struct mv88e6xxx_chip *chip, int port)
 {
 	struct dsa_switch *ds = chip->ds;
@@ -5414,6 +5458,7 @@ static const struct dsa_switch_ops mv88e
 	.port_hwtstamp_get	= mv88e6xxx_port_hwtstamp_get,
 	.port_txtstamp		= mv88e6xxx_port_txtstamp,
 	.port_rxtstamp		= mv88e6xxx_port_rxtstamp,
+	.port_change_cpu_port   = mv88e6xxx_port_change_cpu_port,
 	.get_ts_info		= mv88e6xxx_get_ts_info,
 	.devlink_param_get	= mv88e6xxx_devlink_param_get,
 	.devlink_param_set	= mv88e6xxx_devlink_param_set,

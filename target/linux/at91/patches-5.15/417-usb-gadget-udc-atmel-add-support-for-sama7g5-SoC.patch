From cfb7c8d9ed584b320a6e151c7e40ab5f373c220a Mon Sep 17 00:00:00 2001
From: Cristian Birsan <cristian.birsan@microchip.com>
Date: Wed, 23 Feb 2022 22:43:01 +0200
Subject: [PATCH 308/471] usb: gadget: udc: atmel: add support for sama7g5 SoC

Add support for sama7g5 SoC which requires an USB phy driver.

Signed-off-by: Cristian Birsan <cristian.birsan@microchip.com>
---
 drivers/usb/gadget/udc/atmel_usba_udc.c | 42 ++++++++++++++++++++++++-
 drivers/usb/gadget/udc/atmel_usba_udc.h |  2 ++
 2 files changed, 43 insertions(+), 1 deletion(-)

diff --git a/drivers/usb/gadget/udc/atmel_usba_udc.c b/drivers/usb/gadget/udc/atmel_usba_udc.c
index 2b893bceea45..e93e8f980b47 100644
--- a/drivers/usb/gadget/udc/atmel_usba_udc.c
+++ b/drivers/usb/gadget/udc/atmel_usba_udc.c
@@ -1861,6 +1861,8 @@ static int start_clock(struct usba_udc *udc)
 
 	pm_stay_awake(&udc->pdev->dev);
 
+	phy_power_on(udc->phy);
+
 	ret = clk_prepare_enable(udc->pclk);
 	if (ret)
 		return ret;
@@ -1882,6 +1884,8 @@ static void stop_clock(struct usba_udc *udc)
 	clk_disable_unprepare(udc->hclk);
 	clk_disable_unprepare(udc->pclk);
 
+	phy_power_off(udc->phy);
+
 	udc->clocked = false;
 
 	pm_relax(&udc->pdev->dev);
@@ -1947,6 +1951,7 @@ static irqreturn_t usba_vbus_irq_thread(int irq, void *devid)
 	vbus = vbus_is_present(udc);
 	if (vbus != udc->vbus_prev) {
 		if (vbus) {
+			phy_set_mode_ext(udc->phy, PHY_MODE_USB_DEVICE, 1);
 			usba_start(udc);
 		} else {
 			udc->suspended = false;
@@ -1954,6 +1959,7 @@ static irqreturn_t usba_vbus_irq_thread(int irq, void *devid)
 				udc->driver->disconnect(&udc->gadget);
 
 			usba_stop(udc);
+			phy_set_mode_ext(udc->phy, PHY_MODE_USB_DEVICE, 0);
 		}
 		udc->vbus_prev = vbus;
 	}
@@ -2000,6 +2006,7 @@ static int atmel_usba_start(struct usb_gadget *gadget,
 	/* If Vbus is present, enable the controller and wait for reset */
 	udc->vbus_prev = vbus_is_present(udc);
 	if (udc->vbus_prev) {
+		phy_set_mode_ext(udc->phy, PHY_MODE_USB_DEVICE, 1);
 		ret = usba_start(udc);
 		if (ret)
 			goto err;
@@ -2086,6 +2093,25 @@ static const struct usba_ep_config ep_config_sama5[] __initconst = {
 	{ .nr_banks = 2, .can_isoc = 1 },		/* ep 15 */
 };
 
+static const struct usba_ep_config ep_config_sama7[] __initconst = {
+	{ .nr_banks = 1 },				/* ep 0 */
+	{ .nr_banks = 3, .can_dma = 1, .can_isoc = 1 },	/* ep 1 */
+	{ .nr_banks = 3, .can_dma = 1, .can_isoc = 1 },	/* ep 2 */
+	{ .nr_banks = 2, .can_dma = 1, .can_isoc = 1 },	/* ep 3 */
+	{ .nr_banks = 2, .can_dma = 1, .can_isoc = 1 },	/* ep 4 */
+	{ .nr_banks = 2, .can_dma = 1, .can_isoc = 1 },	/* ep 5 */
+	{ .nr_banks = 2, .can_dma = 1, .can_isoc = 1 },	/* ep 6 */
+	{ .nr_banks = 2, .can_dma = 1, .can_isoc = 1 },	/* ep 7 */
+	{ .nr_banks = 1 },				/* ep 8 */
+	{ .nr_banks = 1 },				/* ep 9 */
+	{ .nr_banks = 1 },				/* ep 10 */
+	{ .nr_banks = 1 },				/* ep 11 */
+	{ .nr_banks = 1 },				/* ep 12 */
+	{ .nr_banks = 1 },				/* ep 13 */
+	{ .nr_banks = 1 },				/* ep 14 */
+	{ .nr_banks = 1 },				/* ep 15 */
+};
+
 static const struct usba_udc_config udc_at91sam9rl_cfg = {
 	.errata = &at91sam9rl_errata,
 	.config = ep_config_sam9,
@@ -2112,11 +2138,18 @@ static const struct usba_udc_config udc_sam9x60_cfg = {
 	.ep_prealloc = false,
 };
 
+static const struct usba_udc_config udc_sama7g5_cfg = {
+	.num_ep = ARRAY_SIZE(ep_config_sama7),
+	.config = ep_config_sama7,
+	.ep_prealloc = false,
+};
+
 static const struct of_device_id atmel_udc_dt_ids[] = {
 	{ .compatible = "atmel,at91sam9rl-udc", .data = &udc_at91sam9rl_cfg },
 	{ .compatible = "atmel,at91sam9g45-udc", .data = &udc_at91sam9g45_cfg },
 	{ .compatible = "atmel,sama5d3-udc", .data = &udc_sama5d3_cfg },
 	{ .compatible = "microchip,sam9x60-udc", .data = &udc_sam9x60_cfg },
+	{ .compatible = "microchip,sama7g5-udc", .data = &udc_sama7g5_cfg },
 	{ /* sentinel */ }
 };
 
@@ -2158,6 +2191,8 @@ static struct usba_ep * atmel_udc_of_init(struct platform_device *pdev,
 			return ERR_CAST(udc->pmc);
 	}
 
+	udc->phy = devm_phy_optional_get(&pdev->dev, "usb");
+
 	udc->num_ep = 0;
 
 	udc->vbus_pin = devm_gpiod_get_optional(&pdev->dev, "atmel,vbus",
@@ -2324,6 +2359,9 @@ static int usba_udc_probe(struct platform_device *pdev)
 
 	udc->usba_ep = atmel_udc_of_init(pdev, udc);
 
+	phy_init(udc->phy);
+	phy_set_mode(udc->phy, PHY_MODE_USB_DEVICE);
+
 	toggle_bias(udc, 0);
 
 	if (IS_ERR(udc->usba_ep))
@@ -2433,8 +2471,10 @@ static int usba_udc_resume(struct device *dev)
 	/* If Vbus is present, enable the controller and wait for reset */
 	mutex_lock(&udc->vbus_mutex);
 	udc->vbus_prev = vbus_is_present(udc);
-	if (udc->vbus_prev)
+	if (udc->vbus_prev) {
+		phy_set_mode_ext(udc->phy, PHY_MODE_USB_DEVICE, 1);
 		usba_start(udc);
+	}
 	mutex_unlock(&udc->vbus_mutex);
 
 	return 0;
diff --git a/drivers/usb/gadget/udc/atmel_usba_udc.h b/drivers/usb/gadget/udc/atmel_usba_udc.h
index 620472f218bc..3803bf8af9c3 100644
--- a/drivers/usb/gadget/udc/atmel_usba_udc.h
+++ b/drivers/usb/gadget/udc/atmel_usba_udc.h
@@ -8,6 +8,7 @@
 #define __LINUX_USB_GADGET_USBA_UDC_H__
 
 #include <linux/gpio/consumer.h>
+#include <linux/phy/phy.h>
 
 /* USB register offsets */
 #define USBA_CTRL				0x0000
@@ -357,6 +358,7 @@ struct usba_udc {
 	struct dentry *debugfs_root;
 #endif
 
+	struct phy *phy;
 	struct regmap *pmc;
 };
 
-- 
2.34.1


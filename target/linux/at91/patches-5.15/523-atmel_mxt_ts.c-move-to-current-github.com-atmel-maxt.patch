From 06c26f0a83ae3ba958a945517216ad667d78d292 Mon Sep 17 00:00:00 2001
From: Nicolas Ferre <nicolas.ferre@microchip.com>
Date: Mon, 12 Jun 2017 15:43:45 +0200
Subject: [PATCH 414/471] atmel_mxt_ts.c: move to current
 github.com/atmel-maxtouch

This is driver from commit ID: 72c03333f35f7eddd707680d8e5de3527b5ef674.

Signed-off-by: Nicolas Ferre <nicolas.ferre@microchip.com>
[eugen.hristev@microchip.com: adapted original patch to 4.14]
Signed-off-by: Eugen Hristev <eugen.hristev@microchip.com>
[claudiu.beznea@microchip.com: adapt to 4.19, 5.4, 5.10, 5.15]
Signed-off-by: Claudiu Beznea <claudiu.beznea@microchip.com>
---
 drivers/input/touchscreen/atmel_mxt_ts.c   | 2124 ++++++++++++--------
 include/dt-bindings/input/atmel_mxt_ts.h   |   22 +
 include/linux/platform_data/atmel_mxt_ts.h |    4 +
 3 files changed, 1282 insertions(+), 868 deletions(-)
 create mode 100644 include/dt-bindings/input/atmel_mxt_ts.h

diff --git a/drivers/input/touchscreen/atmel_mxt_ts.c b/drivers/input/touchscreen/atmel_mxt_ts.c
index f0bca81837c4..ccfb83a85906 100644
--- a/drivers/input/touchscreen/atmel_mxt_ts.c
+++ b/drivers/input/touchscreen/atmel_mxt_ts.c
@@ -18,11 +18,12 @@
 #include <linux/delay.h>
 #include <linux/firmware.h>
 #include <linux/i2c.h>
+#include <linux/platform_data/atmel_mxt_ts.h>
 #include <linux/input/mt.h>
 #include <linux/interrupt.h>
 #include <linux/irq.h>
 #include <linux/of.h>
-#include <linux/property.h>
+#include <linux/of_gpio.h>
 #include <linux/slab.h>
 #include <linux/regulator/consumer.h>
 #include <linux/gpio/consumer.h>
@@ -32,10 +33,15 @@
 #include <media/videobuf2-v4l2.h>
 #include <media/videobuf2-vmalloc.h>
 #include <dt-bindings/input/atmel-maxtouch.h>
+#include <linux/regulator/consumer.h>
+#include <linux/gpio.h>
+#include <linux/workqueue.h>
 
 /* Firmware files */
 #define MXT_FW_NAME		"maxtouch.fw"
 #define MXT_CFG_NAME		"maxtouch.cfg"
+
+/* Configuration file */
 #define MXT_CFG_MAGIC		"OBP_RAW V1"
 
 /* Registers */
@@ -73,7 +79,10 @@
 #define MXT_SPT_MESSAGECOUNT_T44	44
 #define MXT_SPT_CTECONFIG_T46		46
 #define MXT_SPT_DYNAMICCONFIGURATIONCONTAINER_T71 71
+#define MXT_PROCI_SYMBOLGESTUREPROCESSOR	92
+#define MXT_PROCI_TOUCHSEQUENCELOGGER	93
 #define MXT_TOUCH_MULTITOUCHSCREEN_T100 100
+#define MXT_PROCI_ACTIVESTYLUS_T107	107
 
 /* MXT_GEN_MESSAGE_T5 object */
 #define MXT_RPTID_NOMSG		0xff
@@ -104,8 +113,6 @@ struct t7_config {
 
 /* MXT_TOUCH_MULTI_T9 field */
 #define MXT_T9_CTRL		0
-#define MXT_T9_XSIZE		3
-#define MXT_T9_YSIZE		4
 #define MXT_T9_ORIENT		9
 #define MXT_T9_RANGE		18
 
@@ -126,8 +133,6 @@ struct t9_range {
 
 /* MXT_TOUCH_MULTI_T9 orient */
 #define MXT_T9_ORIENT_SWITCH	BIT(0)
-#define MXT_T9_ORIENT_INVERTX	BIT(1)
-#define MXT_T9_ORIENT_INVERTY	BIT(2)
 
 /* MXT_SPT_COMMSCONFIG_T18 */
 #define MXT_COMMS_CTRL		0
@@ -157,18 +162,17 @@ struct t37_debug {
 #define MXT_RESET_VALUE		0x01
 #define MXT_BACKUP_VALUE	0x55
 
+/* Define for MXT_PROCI_TOUCHSUPPRESSION_T42 */
+#define MXT_T42_MSG_TCHSUP	BIT(0)
+
 /* T100 Multiple Touch Touchscreen */
 #define MXT_T100_CTRL		0
 #define MXT_T100_CFG1		1
 #define MXT_T100_TCHAUX		3
-#define MXT_T100_XSIZE		9
 #define MXT_T100_XRANGE		13
-#define MXT_T100_YSIZE		20
 #define MXT_T100_YRANGE		24
 
 #define MXT_T100_CFG_SWITCHXY	BIT(5)
-#define MXT_T100_CFG_INVERTY	BIT(6)
-#define MXT_T100_CFG_INVERTX	BIT(7)
 
 #define MXT_T100_TCHAUX_VECT	BIT(0)
 #define MXT_T100_TCHAUX_AMPL	BIT(1)
@@ -180,6 +184,7 @@ struct t37_debug {
 enum t100_type {
 	MXT_T100_TYPE_FINGER		= 1,
 	MXT_T100_TYPE_PASSIVE_STYLUS	= 2,
+	MXT_T100_TYPE_ACTIVE_STYLUS	= 3,
 	MXT_T100_TYPE_HOVERING_FINGER	= 4,
 	MXT_T100_TYPE_GLOVE		= 5,
 	MXT_T100_TYPE_LARGE_TOUCH	= 6,
@@ -191,16 +196,28 @@ enum t100_type {
 #define MXT_TOUCH_MAJOR_DEFAULT		1
 #define MXT_PRESSURE_DEFAULT		1
 
+/* Gen2 Active Stylus */
+#define MXT_T107_STYLUS_STYAUX		42
+#define MXT_T107_STYLUS_STYAUX_PRESSURE	BIT(0)
+#define MXT_T107_STYLUS_STYAUX_PEAK	BIT(4)
+
+#define MXT_T107_STYLUS_HOVER		BIT(0)
+#define MXT_T107_STYLUS_TIPSWITCH	BIT(1)
+#define MXT_T107_STYLUS_BUTTON0		BIT(2)
+#define MXT_T107_STYLUS_BUTTON1		BIT(3)
+
 /* Delay times */
 #define MXT_BACKUP_TIME		50	/* msec */
-#define MXT_RESET_GPIO_TIME	20	/* msec */
-#define MXT_RESET_INVALID_CHG	100	/* msec */
 #define MXT_RESET_TIME		200	/* msec */
 #define MXT_RESET_TIMEOUT	3000	/* msec */
 #define MXT_CRC_TIMEOUT		1000	/* msec */
 #define MXT_FW_RESET_TIME	3000	/* msec */
 #define MXT_FW_CHG_TIMEOUT	300	/* msec */
 #define MXT_WAKEUP_TIME		25	/* msec */
+#define MXT_REGULATOR_DELAY	150	/* msec */
+#define MXT_CHG_DELAY	        100	/* msec */
+#define MXT_POWERON_DELAY	150	/* msec */
+#define MXT_BOOTLOADER_WAIT	36E5	/* 1 minute */
 
 /* Command to unlock bootloader */
 #define MXT_UNLOCK_CMD_MSB	0xaa
@@ -222,6 +239,8 @@ enum t100_type {
 
 #define MXT_PIXELS_PER_MM	20
 
+#define DEBUG_MSG_MAX		200
+
 struct mxt_info {
 	u8 family_id;
 	u8 variant_id;
@@ -240,30 +259,10 @@ struct mxt_object {
 	u8 num_report_ids;
 } __packed;
 
-struct mxt_dbg {
-	u16 t37_address;
-	u16 diag_cmd_address;
-	struct t37_debug *t37_buf;
-	unsigned int t37_pages;
-	unsigned int t37_nodes;
-
-	struct v4l2_device v4l2;
-	struct v4l2_pix_format format;
-	struct video_device vdev;
-	struct vb2_queue queue;
-	struct mutex lock;
-	int input;
-};
-
-enum v4l_dbg_inputs {
-	MXT_V4L_INPUT_DELTAS,
-	MXT_V4L_INPUT_REFS,
-	MXT_V4L_INPUT_MAX,
-};
-
-enum mxt_suspend_mode {
-	MXT_SUSPEND_DEEP_SLEEP	= 0,
-	MXT_SUSPEND_T9_CTRL	= 1,
+/* Firmware frame structure */
+struct mxt_fw_frame {
+	__be16 size;
+	u8 data[];
 };
 
 /* Config update context */
@@ -279,27 +278,45 @@ struct mxt_cfg {
 	struct mxt_info info;
 };
 
+/* Firmware update context */
+struct mxt_flash {
+	struct mxt_data *data;
+	const struct firmware *fw;
+	struct mxt_fw_frame *frame;
+	loff_t pos;
+	size_t frame_size;
+	unsigned int count;
+	unsigned int retry;
+	u8 previous;
+	struct completion flash_completion;
+	struct delayed_work work;
+};
+
 /* Each client has this additional data */
 struct mxt_data {
 	struct i2c_client *client;
 	struct input_dev *input_dev;
 	char phys[64];		/* device physical location */
+	const struct mxt_platform_data *pdata;
 	struct mxt_object *object_table;
 	struct mxt_info *info;
 	void *raw_info_block;
 	unsigned int irq;
 	unsigned int max_x;
 	unsigned int max_y;
-	bool invertx;
-	bool inverty;
 	bool xy_switch;
-	u8 xsize;
-	u8 ysize;
 	bool in_bootloader;
 	u16 mem_size;
 	u8 t100_aux_ampl;
 	u8 t100_aux_area;
 	u8 t100_aux_vect;
+	struct bin_attribute mem_access_attr;
+	bool debug_enabled;
+	bool debug_v2_enabled;
+	u8 *debug_msg_data;
+	u16 debug_msg_count;
+	struct bin_attribute debug_msg_attr;
+	struct mutex debug_msg_lock;
 	u8 max_reportid;
 	u32 config_crc;
 	u32 info_crc;
@@ -311,11 +328,16 @@ struct mxt_data {
 	u8 num_touchids;
 	u8 multitouch;
 	struct t7_config t7_cfg;
-	struct mxt_dbg dbg;
 	struct regulator_bulk_data regulators[2];
+	unsigned long t15_keystatus;
+	u8 stylus_aux_pressure;
+	u8 stylus_aux_peak;
 	struct gpio_desc *reset_gpio;
 	struct gpio_desc *wake_gpio;
 	bool use_retrigen_workaround;
+	char *fw_name;
+	char *cfg_name;
+	struct mxt_flash *flash;
 
 	/* Cached parameters from object table */
 	u16 T5_address;
@@ -326,11 +348,21 @@ struct mxt_data {
 	u16 T71_address;
 	u8 T9_reportid_min;
 	u8 T9_reportid_max;
+	u8 T15_reportid_min;
+	u8 T15_reportid_max;
 	u16 T18_address;
 	u8 T19_reportid;
+	u8 T42_reportid_min;
+	u8 T42_reportid_max;
 	u16 T44_address;
+	u8 T48_reportid;
+	u16 T92_address;
+	u8 T92_reportid;
+	u16 T93_address;
+	u8 T93_reportid;
 	u8 T100_reportid_min;
 	u8 T100_reportid_max;
+	u16 T107_address;
 
 	/* for reset handling */
 	struct completion reset_completion;
@@ -349,11 +381,9 @@ struct mxt_data {
 	bool suspended;
 	
 	u32 wakeup_method;
-};
 
-struct mxt_vb2_buffer {
-	struct vb2_buffer	vb;
-	struct list_head	list;
+	/* Indicates whether device is updating configuration */
+	bool updating_config;
 };
 
 static size_t mxt_obj_size(const struct mxt_object *obj)
@@ -403,8 +433,138 @@ static bool mxt_object_readable(unsigned int type)
 
 static void mxt_dump_message(struct mxt_data *data, u8 *message)
 {
-	dev_dbg(&data->client->dev, "message: %*ph\n",
-		data->T5_msg_size, message);
+	dev_dbg(&data->client->dev, "MXT MSG: %*ph\n",
+		       data->T5_msg_size, message);
+}
+
+static void mxt_debug_msg_enable(struct mxt_data *data)
+{
+	struct device *dev = &data->client->dev;
+
+	if (data->debug_v2_enabled)
+		return;
+
+	mutex_lock(&data->debug_msg_lock);
+
+	data->debug_msg_data = kcalloc(DEBUG_MSG_MAX,
+				data->T5_msg_size, GFP_KERNEL);
+	if (!data->debug_msg_data)
+		return;
+
+	data->debug_v2_enabled = true;
+	mutex_unlock(&data->debug_msg_lock);
+
+	dev_dbg(dev, "Enabled message output\n");
+}
+
+static void mxt_debug_msg_disable(struct mxt_data *data)
+{
+	struct device *dev = &data->client->dev;
+
+	if (!data->debug_v2_enabled)
+		return;
+
+	data->debug_v2_enabled = false;
+
+	mutex_lock(&data->debug_msg_lock);
+	kfree(data->debug_msg_data);
+	data->debug_msg_data = NULL;
+	data->debug_msg_count = 0;
+	mutex_unlock(&data->debug_msg_lock);
+	dev_dbg(dev, "Disabled message output\n");
+}
+
+static void mxt_debug_msg_add(struct mxt_data *data, u8 *msg)
+{
+	struct device *dev = &data->client->dev;
+
+	mutex_lock(&data->debug_msg_lock);
+
+	if (!data->debug_msg_data) {
+		dev_err(dev, "No buffer!\n");
+		return;
+	}
+
+	if (data->debug_msg_count < DEBUG_MSG_MAX) {
+		memcpy(data->debug_msg_data +
+		       data->debug_msg_count * data->T5_msg_size,
+		       msg,
+		       data->T5_msg_size);
+		data->debug_msg_count++;
+	} else {
+		dev_dbg(dev, "Discarding %u messages\n", data->debug_msg_count);
+		data->debug_msg_count = 0;
+	}
+
+	mutex_unlock(&data->debug_msg_lock);
+
+	sysfs_notify(&data->client->dev.kobj, NULL, "debug_notify");
+}
+
+static ssize_t mxt_debug_msg_write(struct file *filp, struct kobject *kobj,
+	struct bin_attribute *bin_attr, char *buf, loff_t off,
+	size_t count)
+{
+	return -EIO;
+}
+
+static ssize_t mxt_debug_msg_read(struct file *filp, struct kobject *kobj,
+	struct bin_attribute *bin_attr, char *buf, loff_t off, size_t bytes)
+{
+	struct device *dev = container_of(kobj, struct device, kobj);
+	struct mxt_data *data = dev_get_drvdata(dev);
+	int count;
+	size_t bytes_read;
+
+	if (!data->debug_msg_data) {
+		dev_err(dev, "No buffer!\n");
+		return 0;
+	}
+
+	count = bytes / data->T5_msg_size;
+
+	if (count > DEBUG_MSG_MAX)
+		count = DEBUG_MSG_MAX;
+
+	mutex_lock(&data->debug_msg_lock);
+
+	if (count > data->debug_msg_count)
+		count = data->debug_msg_count;
+
+	bytes_read = count * data->T5_msg_size;
+
+	memcpy(buf, data->debug_msg_data, bytes_read);
+	data->debug_msg_count = 0;
+
+	mutex_unlock(&data->debug_msg_lock);
+
+	return bytes_read;
+}
+
+static int mxt_debug_msg_init(struct mxt_data *data)
+{
+	sysfs_bin_attr_init(&data->debug_msg_attr);
+	data->debug_msg_attr.attr.name = "debug_msg";
+	data->debug_msg_attr.attr.mode = 0666;
+	data->debug_msg_attr.read = mxt_debug_msg_read;
+	data->debug_msg_attr.write = mxt_debug_msg_write;
+	data->debug_msg_attr.size = data->T5_msg_size * DEBUG_MSG_MAX;
+
+	if (sysfs_create_bin_file(&data->client->dev.kobj,
+				  &data->debug_msg_attr) < 0) {
+		dev_err(&data->client->dev, "Failed to create %s\n",
+			data->debug_msg_attr.attr.name);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static void mxt_debug_msg_remove(struct mxt_data *data)
+{
+	if (data->debug_msg_attr.attr.name)
+		sysfs_remove_bin_file(&data->client->dev.kobj,
+				      &data->debug_msg_attr);
 }
 
 static int mxt_wait_for_completion(struct mxt_data *data,
@@ -509,111 +669,139 @@ static int mxt_probe_bootloader(struct mxt_data *data, bool alt_address)
 {
 	struct device *dev = &data->client->dev;
 	int error;
-	u8 val;
-	bool crc_failure;
+	u8 buf[3];
+	bool crc_failure, extended_id;
 
 	error = mxt_lookup_bootloader_address(data, alt_address);
 	if (error)
 		return error;
 
-	error = mxt_bootloader_read(data, &val, 1);
+	/* Check bootloader status and version information */
+	error = mxt_bootloader_read(data, buf, sizeof(buf));
 	if (error)
 		return error;
 
-	/* Check app crc fail mode */
-	crc_failure = (val & ~MXT_BOOT_STATUS_MASK) == MXT_APP_CRC_FAIL;
+	crc_failure = (buf[0] & ~MXT_BOOT_STATUS_MASK) == MXT_APP_CRC_FAIL;
+	extended_id = buf[0] & MXT_BOOT_EXTENDED_ID;
 
-	dev_err(dev, "Detected bootloader, status:%02X%s\n",
-			val, crc_failure ? ", APP_CRC_FAIL" : "");
+	dev_info(dev, "Found bootloader addr:%02x ID:%u%s%u%s\n",
+		 data->bootloader_addr,
+		 extended_id ? (buf[1] & MXT_BOOT_ID_MASK) : buf[0],
+		 extended_id ? " version:" : "",
+		 extended_id ? buf[2] : 0,
+		 crc_failure ? ", APP_CRC_FAIL" : "");
 
 	return 0;
 }
 
-static u8 mxt_get_bootloader_version(struct mxt_data *data, u8 val)
-{
-	struct device *dev = &data->client->dev;
-	u8 buf[3];
-
-	if (val & MXT_BOOT_EXTENDED_ID) {
-		if (mxt_bootloader_read(data, &buf[0], 3) != 0) {
-			dev_err(dev, "%s: i2c failure\n", __func__);
-			return val;
-		}
+static int mxt_send_bootloader_cmd(struct mxt_data *data, bool unlock);
 
-		dev_dbg(dev, "Bootloader ID:%d Version:%d\n", buf[1], buf[2]);
+static int mxt_write_firmware_frame(struct mxt_data *data, struct mxt_flash *f)
+{
+	f->frame = (struct mxt_fw_frame *)(f->fw->data + f->pos);
 
-		return buf[0];
-	} else {
-		dev_dbg(dev, "Bootloader ID:%d\n", val & MXT_BOOT_ID_MASK);
+	/* Take account of CRC bytes */
+	f->frame_size = __be16_to_cpu(f->frame->size) + 2U;
 
-		return val;
-	}
+	/* Write one frame to device */
+	return mxt_bootloader_write(data, f->fw->data + f->pos,
+				   f->frame_size);
 }
 
-static int mxt_check_bootloader(struct mxt_data *data, unsigned int state,
-				bool wait)
+static int mxt_check_bootloader(struct mxt_data *data)
 {
 	struct device *dev = &data->client->dev;
-	u8 val;
+	struct mxt_flash *f = data->flash;
+	u8 state;
 	int ret;
 
-recheck:
-	if (wait) {
-		/*
-		 * In application update mode, the interrupt
-		 * line signals state transitions. We must wait for the
-		 * CHG assertion before reading the status byte.
-		 * Once the status byte has been read, the line is deasserted.
-		 */
-		ret = mxt_wait_for_completion(data, &data->chg_completion,
-					      MXT_FW_CHG_TIMEOUT);
-		if (ret) {
-			/*
-			 * TODO: handle -ERESTARTSYS better by terminating
-			 * fw update process before returning to userspace
-			 * by writing length 0x000 to device (iff we are in
-			 * WAITING_FRAME_DATA state).
-			 */
-			dev_err(dev, "Update wait error %d\n", ret);
-			return ret;
-		}
+	/* Handle interrupt after download/flash process */
+	if (f->pos >= f->fw->size) {
+		complete(&f->flash_completion);
+		return 0;
 	}
 
-	ret = mxt_bootloader_read(data, &val, 1);
+	ret = mxt_bootloader_read(data, &state, 1);
 	if (ret)
 		return ret;
 
-	if (state == MXT_WAITING_BOOTLOAD_CMD)
-		val = mxt_get_bootloader_version(data, val);
+	/* Remove don't care bits */
+	if (state & ~MXT_BOOT_STATUS_MASK)
+		state &= ~MXT_BOOT_STATUS_MASK;
 
 	switch (state) {
 	case MXT_WAITING_BOOTLOAD_CMD:
+		dev_info(dev, "Unlocking bootloader\n");
+		ret = mxt_send_bootloader_cmd(data, true);
+		if (ret)
+			return ret;
+
+		break;
+
 	case MXT_WAITING_FRAME_DATA:
-	case MXT_APP_CRC_FAIL:
-		val &= ~MXT_BOOT_STATUS_MASK;
+		if ((f->previous != MXT_WAITING_BOOTLOAD_CMD)
+		    && (f->previous != MXT_FRAME_CRC_PASS)
+		    && (f->previous != MXT_FRAME_CRC_FAIL))
+			goto unexpected;
+
+		ret = mxt_write_firmware_frame(data, f);
+		if (ret)
+			return ret;
+
+		break;
+
+	case MXT_FRAME_CRC_CHECK:
+		if (f->previous != MXT_WAITING_FRAME_DATA)
+			goto unexpected;
 		break;
+
 	case MXT_FRAME_CRC_PASS:
-		if (val == MXT_FRAME_CRC_CHECK) {
-			goto recheck;
-		} else if (val == MXT_FRAME_CRC_FAIL) {
-			dev_err(dev, "Bootloader CRC fail\n");
-			return -EINVAL;
+		if (f->previous != MXT_FRAME_CRC_CHECK)
+			goto unexpected;
+
+		/* Next frame */
+		f->retry = 0;
+		f->pos += f->frame_size;
+		f->count++;
+
+		if (f->pos >= f->fw->size)
+			dev_info(dev, "Sent %u frames, %zu bytes\n",
+				f->count, f->fw->size);
+		else if (f->count % 50 == 0)
+			dev_dbg(dev, "Sent %u frames, %lld/%zu bytes\n",
+				f->count, f->pos, f->fw->size);
+
+		break;
+
+	case MXT_FRAME_CRC_FAIL:
+		if (f->retry > 20) {
+			dev_err(dev, "Retry count exceeded\n");
+			return -EIO;
 		}
+
+		/* Back off by 20ms per retry */
+		dev_dbg(dev, "Bootloader frame CRC failure\n");
+		f->retry++;
+		msleep(f->retry * 20);
 		break;
+
 	default:
 		return -EINVAL;
 	}
 
-	if (val != state) {
-		dev_err(dev, "Invalid bootloader state %02X != %02X\n",
-			val, state);
-		return -EINVAL;
-	}
+	f->previous = state;
+
+	/* Poll after 0.1s if no interrupt received */
+	schedule_delayed_work(&f->work, HZ / 10);
 
 	return 0;
+
+unexpected:
+	dev_err(dev, "Unexpected state transition\n");
+	return -EINVAL;
 }
 
-static int mxt_send_bootloader_cmd(struct mxt_data *data, bool unlock)
+int mxt_send_bootloader_cmd(struct mxt_data *data, bool unlock)
 {
 	u8 buf[2];
 
@@ -826,23 +1014,26 @@ static int mxt_write_object(struct mxt_data *data,
 static void mxt_input_button(struct mxt_data *data, u8 *message)
 {
 	struct input_dev *input = data->input_dev;
+	const struct mxt_platform_data *pdata = data->pdata;
 	int i;
 
-	for (i = 0; i < data->t19_num_keys; i++) {
-		if (data->t19_keymap[i] == KEY_RESERVED)
+	for (i = 0; i < pdata->t19_num_keys; i++) {
+		if (pdata->t19_keymap[i] == KEY_RESERVED)
 			continue;
 
 		/* Active-low switch */
-		input_report_key(input, data->t19_keymap[i],
+		input_report_key(input, pdata->t19_keymap[i],
 				 !(message[1] & BIT(i)));
 	}
 }
 
 static void mxt_input_sync(struct mxt_data *data)
 {
-	input_mt_report_pointer_emulation(data->input_dev,
-					  data->t19_num_keys);
-	input_sync(data->input_dev);
+	if (data->input_dev) {
+		input_mt_report_pointer_emulation(data->input_dev,
+				data->pdata->t19_num_keys);
+		input_sync(data->input_dev);
+	}
 }
 
 static void mxt_proc_t9_message(struct mxt_data *data, u8 *message)
@@ -855,6 +1046,8 @@ static void mxt_proc_t9_message(struct mxt_data *data, u8 *message)
 	int y;
 	int area;
 	int amplitude;
+	u8 vector;
+	int tool;
 
 	id = message[0] - data->T9_reportid_min;
 	status = message[1];
@@ -868,10 +1061,12 @@ static void mxt_proc_t9_message(struct mxt_data *data, u8 *message)
 		y >>= 2;
 
 	area = message[5];
+
 	amplitude = message[6];
+	vector = message[7];
 
 	dev_dbg(dev,
-		"[%u] %c%c%c%c%c%c%c%c x: %5u y: %5u area: %3u amp: %3u\n",
+		"[%u] %c%c%c%c%c%c%c%c x: %5u y: %5u area: %3u amp: %3u vector: %02X\n",
 		id,
 		(status & MXT_T9_DETECT) ? 'D' : '.',
 		(status & MXT_T9_PRESS) ? 'P' : '.',
@@ -881,7 +1076,7 @@ static void mxt_proc_t9_message(struct mxt_data *data, u8 *message)
 		(status & MXT_T9_AMP) ? 'A' : '.',
 		(status & MXT_T9_SUPPRESS) ? 'S' : '.',
 		(status & MXT_T9_UNGRIP) ? 'U' : '.',
-		x, y, area, amplitude);
+		x, y, area, amplitude, vector);
 
 	input_mt_slot(input_dev, id);
 
@@ -896,16 +1091,25 @@ static void mxt_proc_t9_message(struct mxt_data *data, u8 *message)
 			mxt_input_sync(data);
 		}
 
+		/* A size of zero indicates touch is from a linked T47 Stylus */
+		if (area == 0) {
+			area = MXT_TOUCH_MAJOR_DEFAULT;
+			tool = MT_TOOL_PEN;
+		} else {
+			tool = MT_TOOL_FINGER;
+		}
+
 		/* if active, pressure must be non-zero */
 		if (!amplitude)
 			amplitude = MXT_PRESSURE_DEFAULT;
 
 		/* Touch active */
-		input_mt_report_slot_state(input_dev, MT_TOOL_FINGER, 1);
+		input_mt_report_slot_state(input_dev, tool, 1);
 		input_report_abs(input_dev, ABS_MT_POSITION_X, x);
 		input_report_abs(input_dev, ABS_MT_POSITION_Y, y);
 		input_report_abs(input_dev, ABS_MT_PRESSURE, amplitude);
 		input_report_abs(input_dev, ABS_MT_TOUCH_MAJOR, area);
+		input_report_abs(input_dev, ABS_MT_ORIENTATION, vector);
 	} else {
 		/* Touch no longer active, close out slot */
 		input_mt_report_slot_inactive(input_dev);
@@ -928,6 +1132,8 @@ static void mxt_proc_t100_message(struct mxt_data *data, u8 *message)
 	u8 major = 0;
 	u8 pressure = 0;
 	u8 orientation = 0;
+	bool active = false;
+	bool hover = false;
 
 	id = message[0] - data->T100_reportid_min - 2;
 
@@ -946,16 +1152,16 @@ static void mxt_proc_t100_message(struct mxt_data *data, u8 *message)
 		case MXT_T100_TYPE_HOVERING_FINGER:
 			tool = MT_TOOL_FINGER;
 			distance = MXT_DISTANCE_HOVERING;
-
-			if (data->t100_aux_vect)
-				orientation = message[data->t100_aux_vect];
-
+			hover = true;
+			active = true;
 			break;
 
 		case MXT_T100_TYPE_FINGER:
 		case MXT_T100_TYPE_GLOVE:
 			tool = MT_TOOL_FINGER;
 			distance = MXT_DISTANCE_ACTIVE_TOUCH;
+			hover = false;
+			active = true;
 
 			if (data->t100_aux_area)
 				major = message[data->t100_aux_area];
@@ -970,6 +1176,9 @@ static void mxt_proc_t100_message(struct mxt_data *data, u8 *message)
 
 		case MXT_T100_TYPE_PASSIVE_STYLUS:
 			tool = MT_TOOL_PEN;
+			distance = MXT_DISTANCE_ACTIVE_TOUCH;
+			hover = false;
+			active = true;
 
 			/*
 			 * Passive stylus is reported with size zero so
@@ -982,6 +1191,31 @@ static void mxt_proc_t100_message(struct mxt_data *data, u8 *message)
 
 			break;
 
+		case MXT_T100_TYPE_ACTIVE_STYLUS:
+			/* Report input buttons */
+			input_report_key(input_dev, BTN_STYLUS,
+					 message[6] & MXT_T107_STYLUS_BUTTON0);
+			input_report_key(input_dev, BTN_STYLUS2,
+					 message[6] & MXT_T107_STYLUS_BUTTON1);
+
+			/* stylus in range, but position unavailable */
+			if (!(message[6] & MXT_T107_STYLUS_HOVER))
+				break;
+
+			tool = MT_TOOL_PEN;
+			distance = MXT_DISTANCE_ACTIVE_TOUCH;
+			active = true;
+			major = MXT_TOUCH_MAJOR_DEFAULT;
+
+			if (!(message[6] & MXT_T107_STYLUS_TIPSWITCH)) {
+				hover = true;
+				distance = MXT_DISTANCE_HOVERING;
+			} else if (data->stylus_aux_pressure) {
+				pressure = message[data->stylus_aux_pressure];
+			}
+
+			break;
+
 		case MXT_T100_TYPE_LARGE_TOUCH:
 			/* Ignore suppressed touch */
 			break;
@@ -996,12 +1230,12 @@ static void mxt_proc_t100_message(struct mxt_data *data, u8 *message)
 	 * Values reported should be non-zero if tool is touching the
 	 * device
 	 */
-	if (!pressure && type != MXT_T100_TYPE_HOVERING_FINGER)
+	if (!pressure && !hover)
 		pressure = MXT_PRESSURE_DEFAULT;
 
 	input_mt_slot(input_dev, id);
 
-	if (status & MXT_T100_DETECT) {
+	if (active) {
 		dev_dbg(dev, "[%u] type:%u x:%u y:%u a:%02X p:%02X v:%02X\n",
 			id, type, x, y, major, pressure, orientation);
 
@@ -1012,6 +1246,7 @@ static void mxt_proc_t100_message(struct mxt_data *data, u8 *message)
 		input_report_abs(input_dev, ABS_MT_PRESSURE, pressure);
 		input_report_abs(input_dev, ABS_MT_DISTANCE, distance);
 		input_report_abs(input_dev, ABS_MT_ORIENTATION, orientation);
+
 	} else {
 		dev_dbg(dev, "[%u] release\n", id);
 
@@ -1022,19 +1257,104 @@ static void mxt_proc_t100_message(struct mxt_data *data, u8 *message)
 	data->update_input = true;
 }
 
+static void mxt_proc_t15_messages(struct mxt_data *data, u8 *msg)
+{
+	struct input_dev *input_dev = data->input_dev;
+	struct device *dev = &data->client->dev;
+	int key;
+	bool curr_state, new_state;
+	bool sync = false;
+	unsigned long keystates = le32_to_cpu(msg[2]);
+
+	for (key = 0; key < data->pdata->t15_num_keys; key++) {
+		curr_state = test_bit(key, &data->t15_keystatus);
+		new_state = test_bit(key, &keystates);
+
+		if (!curr_state && new_state) {
+			dev_dbg(dev, "T15 key press: %u\n", key);
+			__set_bit(key, &data->t15_keystatus);
+			input_event(input_dev, EV_KEY,
+				    data->pdata->t15_keymap[key], 1);
+			sync = true;
+		} else if (curr_state && !new_state) {
+			dev_dbg(dev, "T15 key release: %u\n", key);
+			__clear_bit(key, &data->t15_keystatus);
+			input_event(input_dev, EV_KEY,
+				    data->pdata->t15_keymap[key], 0);
+			sync = true;
+		}
+	}
+
+	if (sync)
+		input_sync(input_dev);
+}
+
+static void mxt_proc_t42_messages(struct mxt_data *data, u8 *msg)
+{
+	struct device *dev = &data->client->dev;
+	u8 status = msg[1];
+
+	if (status & MXT_T42_MSG_TCHSUP)
+		dev_info(dev, "T42 suppress\n");
+	else
+		dev_info(dev, "T42 normal\n");
+}
+
+static int mxt_proc_t48_messages(struct mxt_data *data, u8 *msg)
+{
+	struct device *dev = &data->client->dev;
+	u8 status, state;
+
+	status = msg[1];
+	state  = msg[4];
+
+	dev_dbg(dev, "T48 state %d status %02X %s%s%s%s%s\n", state, status,
+		status & 0x01 ? "FREQCHG " : "",
+		status & 0x02 ? "APXCHG " : "",
+		status & 0x04 ? "ALGOERR " : "",
+		status & 0x10 ? "STATCHG " : "",
+		status & 0x20 ? "NLVLCHG " : "");
+
+	return 0;
+}
+
+static void mxt_proc_t92_messages(struct mxt_data *data, u8 *msg)
+{
+	struct device *dev = &data->client->dev;
+	u8 status = msg[1];
+
+	dev_info(dev, "T92 long stroke LSTR=%d %d\n",
+		 (status & 0x80) ? 1 : 0,
+		 status & 0x0F);
+}
+
+static void mxt_proc_t93_messages(struct mxt_data *data, u8 *msg)
+{
+	struct device *dev = &data->client->dev;
+	u8 status = msg[1];
+
+	dev_info(dev, "T93 report double tap %d\n", status);
+}
+
 static int mxt_proc_message(struct mxt_data *data, u8 *message)
 {
 	u8 report_id = message[0];
+	bool dump = data->debug_enabled;
 
 	if (report_id == MXT_RPTID_NOMSG)
 		return 0;
 
 	if (report_id == data->T6_reportid) {
 		mxt_proc_t6_messages(data, message);
+	} else if (report_id >= data->T42_reportid_min
+		   && report_id <= data->T42_reportid_max) {
+		mxt_proc_t42_messages(data, message);
+	} else if (report_id == data->T48_reportid) {
+		mxt_proc_t48_messages(data, message);
 	} else if (!data->input_dev || data->suspended) {
 		/*
 		 * Do not report events if input device is not
-		 * yet registered or returning from suspend.
+		 * yet registered or returning from suspend
 		 */
 		mxt_dump_message(data, message);
 	} else if (report_id >= data->T9_reportid_min &&
@@ -1046,10 +1366,23 @@ static int mxt_proc_message(struct mxt_data *data, u8 *message)
 	} else if (report_id == data->T19_reportid) {
 		mxt_input_button(data, message);
 		data->update_input = true;
+	} else if (report_id >= data->T15_reportid_min
+		   && report_id <= data->T15_reportid_max) {
+		mxt_proc_t15_messages(data, message);
+	} else if (report_id == data->T92_reportid) {
+		mxt_proc_t92_messages(data, message);
+	} else if (report_id == data->T93_reportid) {
+		mxt_proc_t93_messages(data, message);
 	} else {
-		mxt_dump_message(data, message);
+		dump = true;
 	}
 
+	if (dump)
+		mxt_dump_message(data, message);
+
+	if (data->debug_v2_enabled)
+		mxt_debug_msg_add(data, message);
+
 	return 1;
 }
 
@@ -1208,8 +1541,12 @@ static irqreturn_t mxt_interrupt(int irq, void *dev_id)
 
 	complete(&data->chg_completion);
 
-	if (data->in_bootloader)
-		return IRQ_HANDLED;
+	if (data->in_bootloader) {
+		if (data->flash && &data->flash->work)
+			cancel_delayed_work_sync(&data->flash->work);
+
+		return IRQ_RETVAL(mxt_check_bootloader(data));
+	}
 
 	if (!data->object_table)
 		return IRQ_HANDLED;
@@ -1253,35 +1590,6 @@ static int mxt_t6_command(struct mxt_data *data, u16 cmd_offset,
 	return 0;
 }
 
-static int mxt_acquire_irq(struct mxt_data *data)
-{
-	int error;
-
-	if (!data->irq) {
-		error = devm_request_threaded_irq(&data->client->dev,
-						  data->client->irq, NULL,
-						  mxt_interrupt, IRQF_ONESHOT,
-						  data->client->name, data);
-		if (error) {
-			dev_err(&data->client->dev, "Error requesting irq\n");
-			return error;
-		}
-
-		/* Presence of data->irq means IRQ initialised */
-		data->irq = data->client->irq;
-	} else {
-		enable_irq(data->irq);
-	}
-
-	if (data->use_retrigen_workaround) {
-		error = mxt_process_messages_until_invalid(data);
-		if (error)
-			return error;
-	}
-
-	return 0;
-}
-
 static int mxt_soft_reset(struct mxt_data *data)
 {
 	struct device *dev = &data->client->dev;
@@ -1298,9 +1606,9 @@ static int mxt_soft_reset(struct mxt_data *data)
 		return ret;
 
 	/* Ignore CHG line for 100ms after reset */
-	msleep(MXT_RESET_INVALID_CHG);
+	msleep(100);
 
-	mxt_acquire_irq(data);
+	enable_irq(data->irq);
 
 	ret = mxt_wait_for_completion(data, &data->reset_completion,
 				      MXT_RESET_TIMEOUT);
@@ -1556,10 +1864,12 @@ static int mxt_update_cfg(struct mxt_data *data, const struct firmware *fw)
 	u16 crc_start = 0;
 
 	/* Make zero terminated copy of the OBP_RAW file */
-	cfg.raw = kmemdup_nul(fw->data, fw->size, GFP_KERNEL);
+	cfg.raw = kzalloc(fw->size + 1, GFP_KERNEL);
 	if (!cfg.raw)
 		return -ENOMEM;
 
+	memcpy(cfg.raw, fw->data, fw->size);
+	cfg.raw[fw->size] = '\0';
 	cfg.raw_size = fw->size;
 
 	mxt_update_crc(data, MXT_COMMAND_REPORTALL, 1);
@@ -1691,13 +2001,43 @@ static int mxt_update_cfg(struct mxt_data *data, const struct firmware *fw)
 	/* T7 config may have changed */
 	mxt_init_t7_power_cfg(data);
 
-release_mem:
-	kfree(cfg.mem);
 release_raw:
 	kfree(cfg.raw);
+release_mem:
+	kfree(cfg.mem);
 	return ret;
 }
 
+static int mxt_acquire_irq(struct mxt_data *data)
+{
+	int error;
+
+	if (!data->irq) {
+		error = devm_request_threaded_irq(&data->client->dev,
+				data->client->irq, NULL,
+				mxt_interrupt,
+				data->pdata->irqflags | IRQF_ONESHOT,
+				data->client->name, data);
+		if (error) {
+			dev_err(&data->client->dev, "Error requesting irq\n");
+			return error;
+		}
+
+		/* Presence of data->irq means IRQ initialised */
+		data->irq = data->client->irq;
+	} else {
+		enable_irq(data->irq);
+	}
+
+	if (data->object_table && data->use_retrigen_workaround) {
+		error = mxt_process_messages_until_invalid(data);
+		if (error)
+			return error;
+	}
+
+	return 0;
+}
+
 static void mxt_free_input_device(struct mxt_data *data)
 {
 	if (data->input_dev) {
@@ -1708,10 +2048,6 @@ static void mxt_free_input_device(struct mxt_data *data)
 
 static void mxt_free_object_table(struct mxt_data *data)
 {
-#ifdef CONFIG_TOUCHSCREEN_ATMEL_MXT_T37
-	video_unregister_device(&data->dbg.vdev);
-	v4l2_device_unregister(&data->dbg.v4l2);
-#endif
 	data->object_table = NULL;
 	data->info = NULL;
 	kfree(data->raw_info_block);
@@ -1725,9 +2061,18 @@ static void mxt_free_object_table(struct mxt_data *data)
 	data->T71_address = 0;
 	data->T9_reportid_min = 0;
 	data->T9_reportid_max = 0;
+	data->T15_reportid_min = 0;
+	data->T15_reportid_max = 0;
 	data->T18_address = 0;
 	data->T19_reportid = 0;
+	data->T42_reportid_min = 0;
+	data->T42_reportid_max = 0;
 	data->T44_address = 0;
+	data->T48_reportid = 0;
+	data->T92_reportid = 0;
+	data->T92_address = 0;
+	data->T93_reportid = 0;
+	data->T93_address = 0;
 	data->T100_reportid_min = 0;
 	data->T100_reportid_max = 0;
 	data->max_reportid = 0;
@@ -1800,15 +2145,34 @@ static int mxt_parse_object_table(struct mxt_data *data,
 						object->num_report_ids - 1;
 			data->num_touchids = object->num_report_ids;
 			break;
+		case MXT_TOUCH_KEYARRAY_T15:
+			data->T15_reportid_min = min_id;
+			data->T15_reportid_max = max_id;
+			break;
 		case MXT_SPT_COMMSCONFIG_T18:
 			data->T18_address = object->start_address;
 			break;
+		case MXT_PROCI_TOUCHSUPPRESSION_T42:
+			data->T42_reportid_min = min_id;
+			data->T42_reportid_max = max_id;
+			break;
 		case MXT_SPT_MESSAGECOUNT_T44:
 			data->T44_address = object->start_address;
 			break;
 		case MXT_SPT_GPIOPWM_T19:
 			data->T19_reportid = min_id;
 			break;
+		case MXT_PROCG_NOISESUPPRESSION_T48:
+			data->T48_reportid = min_id;
+			break;
+		case MXT_PROCI_SYMBOLGESTUREPROCESSOR:
+			data->T92_reportid = min_id;
+			data->T92_address = object->start_address;
+			break;
+		case MXT_PROCI_TOUCHSEQUENCELOGGER:
+			data->T93_reportid = min_id;
+			data->T93_address = object->start_address;
+			break;
 		case MXT_TOUCH_MULTITOUCHSCREEN_T100:
 			data->multitouch = MXT_TOUCH_MULTITOUCHSCREEN_T100;
 			data->T100_reportid_min = min_id;
@@ -1816,6 +2180,9 @@ static int mxt_parse_object_table(struct mxt_data *data,
 			/* first two report IDs reserved */
 			data->num_touchids = object->num_report_ids - 2;
 			break;
+		case MXT_PROCI_ACTIVESTYLUS_T107:
+			data->T107_address = object->start_address;
+			break;
 		}
 
 		end_address = object->start_address
@@ -1853,7 +2220,7 @@ static int mxt_read_info_block(struct mxt_data *data)
 	u8 *crc_ptr;
 
 	/* If info block already allocated, free it */
-	if (data->raw_info_block)
+	if (data->raw_info_block != NULL)
 		mxt_free_object_table(data);
 
 	/* Read 7-byte ID information block starting at address 0 */
@@ -1863,8 +2230,10 @@ static int mxt_read_info_block(struct mxt_data *data)
 		return -ENOMEM;
 
 	error = __mxt_read_reg(client, 0, size, id_buf);
-	if (error)
-		goto err_free_mem;
+	if (error) {
+		kfree(id_buf);
+		return error;
+	}
 
 	/* Resize buffer to give space for rest of info block */
 	num_objects = ((struct mxt_info *)id_buf)->object_num;
@@ -1876,20 +2245,19 @@ static int mxt_read_info_block(struct mxt_data *data)
 		error = -ENOMEM;
 		goto err_free_mem;
 	}
-	id_buf = buf;
 
 	/* Read rest of info block */
 	error = mxt_read_blks(data, MXT_OBJECT_START,
-			       size - MXT_OBJECT_START,
-			       id_buf + MXT_OBJECT_START);
+			      size - MXT_OBJECT_START,
+			      buf + MXT_OBJECT_START);
 	if (error)
 		goto err_free_mem;
 
 	/* Extract & calculate checksum */
-	crc_ptr = id_buf + size - MXT_INFO_CHECKSUM_SIZE;
+	crc_ptr = buf + size - MXT_INFO_CHECKSUM_SIZE;
 	data->info_crc = crc_ptr[0] | (crc_ptr[1] << 8) | (crc_ptr[2] << 16);
 
-	calculated_crc = mxt_calculate_crc(id_buf, 0,
+	calculated_crc = mxt_calculate_crc(buf, 0,
 					   size - MXT_INFO_CHECKSUM_SIZE);
 
 	/*
@@ -1904,8 +2272,8 @@ static int mxt_read_info_block(struct mxt_data *data)
 		goto err_free_mem;
 	}
 
-	data->raw_info_block = id_buf;
-	data->info = (struct mxt_info *)id_buf;
+	data->raw_info_block = buf;
+	data->info = (struct mxt_info *)buf;
 
 	dev_info(&client->dev,
 		 "Family: %u Variant: %u Firmware V%u.%u.%02X Objects: %u\n",
@@ -1914,19 +2282,19 @@ static int mxt_read_info_block(struct mxt_data *data)
 		 data->info->build, data->info->object_num);
 
 	/* Parse object table information */
-	error = mxt_parse_object_table(data, id_buf + MXT_OBJECT_START);
+	error = mxt_parse_object_table(data, buf + MXT_OBJECT_START);
 	if (error) {
 		dev_err(&client->dev, "Error %d parsing object table\n", error);
 		mxt_free_object_table(data);
 		return error;
 	}
 
-	data->object_table = (struct mxt_object *)(id_buf + MXT_OBJECT_START);
+	data->object_table = (struct mxt_object *)(buf + MXT_OBJECT_START);
 
 	return 0;
 
 err_free_mem:
-	kfree(id_buf);
+	kfree(buf);
 	return error;
 }
 
@@ -1942,18 +2310,6 @@ static int mxt_read_t9_resolution(struct mxt_data *data)
 	if (!object)
 		return -EINVAL;
 
-	error = __mxt_read_reg(client,
-			       object->start_address + MXT_T9_XSIZE,
-			       sizeof(data->xsize), &data->xsize);
-	if (error)
-		return error;
-
-	error = __mxt_read_reg(client,
-			       object->start_address + MXT_T9_YSIZE,
-			       sizeof(data->ysize), &data->ysize);
-	if (error)
-		return error;
-
 	error = __mxt_read_reg(client,
 			       object->start_address + MXT_T9_RANGE,
 			       sizeof(range), &range);
@@ -1970,8 +2326,54 @@ static int mxt_read_t9_resolution(struct mxt_data *data)
 		return error;
 
 	data->xy_switch = orient & MXT_T9_ORIENT_SWITCH;
-	data->invertx = orient & MXT_T9_ORIENT_INVERTX;
-	data->inverty = orient & MXT_T9_ORIENT_INVERTY;
+
+	return 0;
+}
+
+static int mxt_set_up_active_stylus(struct input_dev *input_dev,
+				    struct mxt_data *data)
+{
+	struct i2c_client *client = data->client;
+	int error;
+	struct mxt_object *object;
+	u8 styaux;
+	int aux;
+	u8 ctrl;
+
+	object = mxt_get_object(data, MXT_PROCI_ACTIVESTYLUS_T107);
+	if (!object)
+		return 0;
+
+	error = __mxt_read_reg(client, object->start_address, 1, &ctrl);
+	if (error)
+		return error;
+
+	/* Check enable bit */
+	if (!(ctrl & 0x01))
+		return 0;
+
+	error = __mxt_read_reg(client,
+			       object->start_address + MXT_T107_STYLUS_STYAUX,
+			       1, &styaux);
+	if (error)
+		return error;
+
+	/* map aux bits */
+	aux = 7;
+
+	if (styaux & MXT_T107_STYLUS_STYAUX_PRESSURE)
+		data->stylus_aux_pressure = aux++;
+
+	if (styaux & MXT_T107_STYLUS_STYAUX_PEAK)
+		data->stylus_aux_peak = aux++;
+
+	input_set_capability(input_dev, EV_KEY, BTN_STYLUS);
+	input_set_capability(input_dev, EV_KEY, BTN_STYLUS2);
+	input_set_abs_params(input_dev, ABS_MT_TOOL_TYPE, 0, MT_TOOL_MAX, 0, 0);
+
+	dev_dbg(&client->dev,
+		"T107 active stylus, aux map pressure:%u peak:%u\n",
+		data->stylus_aux_pressure, data->stylus_aux_peak);
 
 	return 0;
 }
@@ -2006,18 +2408,6 @@ static int mxt_read_t100_config(struct mxt_data *data)
 
 	data->max_y = get_unaligned_le16(&range_y);
 
-	error = __mxt_read_reg(client,
-			       object->start_address + MXT_T100_XSIZE,
-			       sizeof(data->xsize), &data->xsize);
-	if (error)
-		return error;
-
-	error = __mxt_read_reg(client,
-			       object->start_address + MXT_T100_YSIZE,
-			       sizeof(data->ysize), &data->ysize);
-	if (error)
-		return error;
-
 	/* read orientation config */
 	error =  __mxt_read_reg(client,
 				object->start_address + MXT_T100_CFG1,
@@ -2026,8 +2416,6 @@ static int mxt_read_t100_config(struct mxt_data *data)
 		return error;
 
 	data->xy_switch = cfg & MXT_T100_CFG_SWITCHXY;
-	data->invertx = cfg & MXT_T100_CFG_INVERTX;
-	data->inverty = cfg & MXT_T100_CFG_INVERTY;
 
 	/* allocate aux bytes */
 	error =  __mxt_read_reg(client,
@@ -2060,6 +2448,7 @@ static void mxt_input_close(struct input_dev *dev);
 static void mxt_set_up_as_touchpad(struct input_dev *input_dev,
 				   struct mxt_data *data)
 {
+	const struct mxt_platform_data *pdata = data->pdata;
 	int i;
 
 	input_dev->name = "Atmel maXTouch Touchpad";
@@ -2073,19 +2462,21 @@ static void mxt_set_up_as_touchpad(struct input_dev *input_dev,
 	input_abs_set_res(input_dev, ABS_MT_POSITION_Y,
 			  MXT_PIXELS_PER_MM);
 
-	for (i = 0; i < data->t19_num_keys; i++)
-		if (data->t19_keymap[i] != KEY_RESERVED)
+	for (i = 0; i < pdata->t19_num_keys; i++)
+		if (pdata->t19_keymap[i] != KEY_RESERVED)
 			input_set_capability(input_dev, EV_KEY,
-					     data->t19_keymap[i]);
+					     pdata->t19_keymap[i]);
 }
 
 static int mxt_initialize_input_device(struct mxt_data *data)
 {
+	const struct mxt_platform_data *pdata = data->pdata;
 	struct device *dev = &data->client->dev;
 	struct input_dev *input_dev;
 	int error;
 	unsigned int num_mt_slots;
 	unsigned int mt_flags = 0;
+	int i;
 
 	switch (data->multitouch) {
 	case MXT_TOUCH_MULTI_T9:
@@ -2124,13 +2515,18 @@ static int mxt_initialize_input_device(struct mxt_data *data)
 	if (!input_dev)
 		return -ENOMEM;
 
-	input_dev->name = "Atmel maXTouch Touchscreen";
+	if (data->pdata->input_name)
+		input_dev->name = data->pdata->input_name;
+	else
+		input_dev->name = "Atmel maXTouch Touchscreen";
+
 	input_dev->phys = data->phys;
 	input_dev->id.bustype = BUS_I2C;
 	input_dev->dev.parent = dev;
 	input_dev->open = mxt_input_open;
 	input_dev->close = mxt_input_close;
 
+	set_bit(EV_ABS, input_dev->evbit);
 	input_set_capability(input_dev, EV_KEY, BTN_TOUCH);
 
 	/* For single touch */
@@ -2144,7 +2540,7 @@ static int mxt_initialize_input_device(struct mxt_data *data)
 	}
 
 	/* If device has buttons we assume it is a touchpad */
-	if (data->t19_num_keys) {
+	if (pdata->t19_num_keys) {
 		mxt_set_up_as_touchpad(input_dev, data);
 		mt_flags |= INPUT_MT_POINTER;
 	} else {
@@ -2181,7 +2577,7 @@ static int mxt_initialize_input_device(struct mxt_data *data)
 
 	if (data->multitouch == MXT_TOUCH_MULTI_T9 ||
 	    (data->multitouch == MXT_TOUCH_MULTITOUCHSCREEN_T100 &&
-	     data->t100_aux_ampl)) {
+	     (data->t100_aux_ampl || data->stylus_aux_pressure))) {
 		input_set_abs_params(input_dev, ABS_MT_PRESSURE,
 				     0, 255, 0, 0);
 	}
@@ -2192,12 +2588,30 @@ static int mxt_initialize_input_device(struct mxt_data *data)
 				     0, 255, 0, 0);
 	}
 
-	if (data->multitouch == MXT_TOUCH_MULTITOUCHSCREEN_T100 &&
-	    data->t100_aux_vect) {
+	if (data->multitouch == MXT_TOUCH_MULTI_T9 ||
+	    (data->multitouch == MXT_TOUCH_MULTITOUCHSCREEN_T100 &&
+	    data->t100_aux_vect)) {
 		input_set_abs_params(input_dev, ABS_MT_ORIENTATION,
 				     0, 255, 0, 0);
 	}
 
+	/* For T107 Active Stylus */
+	if (data->multitouch == MXT_TOUCH_MULTITOUCHSCREEN_T100 &&
+	    data->T107_address) {
+		error = mxt_set_up_active_stylus(input_dev, data);
+		if (error)
+			dev_warn(dev, "Failed to read T107 config\n");
+	}
+
+	/* For T15 Key Array */
+	if (data->T15_reportid_min) {
+		data->t15_keystatus = 0;
+
+		for (i = 0; i < data->pdata->t15_num_keys; i++)
+			input_set_capability(input_dev, EV_KEY,
+					data->pdata->t15_keymap[i]);
+	}
+
 	input_set_drvdata(input_dev, data);
 
 	error = input_register_device(input_dev);
@@ -2215,6 +2629,9 @@ static int mxt_initialize_input_device(struct mxt_data *data)
 	return error;
 }
 
+static int mxt_sysfs_init(struct mxt_data *data);
+static void mxt_sysfs_remove(struct mxt_data *data);
+
 static int mxt_configure_objects(struct mxt_data *data,
 				 const struct firmware *cfg);
 
@@ -2264,22 +2681,40 @@ static int mxt_initialize(struct mxt_data *data)
 
 	error = mxt_check_retrigen(data);
 	if (error)
-		return error;
+		goto err_free_object_table;
 
 	error = mxt_acquire_irq(data);
 	if (error)
-		return error;
+		goto err_free_object_table;
 
-	error = request_firmware_nowait(THIS_MODULE, true, MXT_CFG_NAME,
-					&client->dev, GFP_KERNEL, data,
-					mxt_config_cb);
-	if (error) {
-		dev_err(&client->dev, "Failed to invoke firmware loader: %d\n",
-			error);
-		return error;
+	error = mxt_sysfs_init(data);
+	if (error)
+		goto err_free_object_table;
+
+	error = mxt_debug_msg_init(data);
+	if (error)
+		goto err_free_object_table;
+
+	if (data->cfg_name) {
+		error = request_firmware_nowait(THIS_MODULE, true,
+					data->cfg_name, &data->client->dev,
+					GFP_KERNEL, data, mxt_config_cb);
+		if (error) {
+			dev_err(&client->dev, "Failed to invoke firmware loader: %d\n",
+				error);
+			goto err_free_object_table;
+		}
+	} else {
+		error = mxt_configure_objects(data, NULL);
+		if (error)
+			goto err_free_object_table;
 	}
 
 	return 0;
+
+err_free_object_table:
+	mxt_free_object_table(data);
+	return error;
 }
 
 static int mxt_set_t7_power_cfg(struct mxt_data *data, u8 sleep)
@@ -2336,727 +2771,489 @@ static int mxt_init_t7_power_cfg(struct mxt_data *data)
 	return 0;
 }
 
-#ifdef CONFIG_TOUCHSCREEN_ATMEL_MXT_T37
-static const struct v4l2_file_operations mxt_video_fops = {
-	.owner = THIS_MODULE,
-	.open = v4l2_fh_open,
-	.release = vb2_fop_release,
-	.unlocked_ioctl = video_ioctl2,
-	.read = vb2_fop_read,
-	.mmap = vb2_fop_mmap,
-	.poll = vb2_fop_poll,
-};
-
-static u16 mxt_get_debug_value(struct mxt_data *data, unsigned int x,
-			       unsigned int y)
+static int mxt_configure_objects(struct mxt_data *data,
+				 const struct firmware *cfg)
 {
-	struct mxt_info *info = data->info;
-	struct mxt_dbg *dbg = &data->dbg;
-	unsigned int ofs, page;
-	unsigned int col = 0;
-	unsigned int col_width;
+	struct device *dev = &data->client->dev;
+	int error;
+
+	error = mxt_init_t7_power_cfg(data);
+	if (error) {
+		dev_err(dev, "Failed to initialize power cfg\n");
+		goto err_free_object_table;
+	}
+
+	if (cfg) {
+		error = mxt_update_cfg(data, cfg);
+		if (error)
+			dev_warn(dev, "Error %d updating config\n", error);
+	}
 
-	if (info->family_id == MXT_FAMILY_1386) {
-		col_width = info->matrix_ysize / MXT1386_COLUMNS;
-		col = y / col_width;
-		y = y % col_width;
+	if (data->multitouch) {
+		error = mxt_initialize_input_device(data);
+		if (error)
+			goto err_free_object_table;
 	} else {
-		col_width = info->matrix_ysize;
+		dev_warn(dev, "No touch object detected\n");
 	}
 
-	ofs = (y + (x * col_width)) * sizeof(u16);
-	page = ofs / MXT_DIAGNOSTIC_SIZE;
-	ofs %= MXT_DIAGNOSTIC_SIZE;
+	return 0;
+
+err_free_object_table:
+	mxt_free_object_table(data);
+	return error;
+}
 
-	if (info->family_id == MXT_FAMILY_1386)
-		page += col * MXT1386_PAGES_PER_COLUMN;
+/* Configuration crc check sum is returned as hex xxxxxx */
+static ssize_t mxt_config_crc_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	struct mxt_data *data = dev_get_drvdata(dev);
 
-	return get_unaligned_le16(&dbg->t37_buf[page].data[ofs]);
+	return scnprintf(buf, PAGE_SIZE, "%06x\n", data->config_crc);
 }
 
-static int mxt_convert_debug_pages(struct mxt_data *data, u16 *outbuf)
+/* Firmware Version is returned as Major.Minor.Build */
+static ssize_t mxt_fw_version_show(struct device *dev,
+				   struct device_attribute *attr, char *buf)
 {
-	struct mxt_dbg *dbg = &data->dbg;
-	unsigned int x = 0;
-	unsigned int y = 0;
-	unsigned int i, rx, ry;
+	struct mxt_data *data = dev_get_drvdata(dev);
+	return scnprintf(buf, PAGE_SIZE, "%u.%u.%02X\n",
+			 data->info->version >> 4, data->info->version & 0xf,
+			 data->info->build);
+}
 
-	for (i = 0; i < dbg->t37_nodes; i++) {
-		/* Handle orientation */
-		rx = data->xy_switch ? y : x;
-		ry = data->xy_switch ? x : y;
-		rx = data->invertx ? (data->xsize - 1 - rx) : rx;
-		ry = data->inverty ? (data->ysize - 1 - ry) : ry;
+/* Hardware Version is returned as FamilyID.VariantID */
+static ssize_t mxt_hw_version_show(struct device *dev,
+				   struct device_attribute *attr, char *buf)
+{
+	struct mxt_data *data = dev_get_drvdata(dev);
+	return scnprintf(buf, PAGE_SIZE, "%u.%u\n",
+			data->info->family_id, data->info->variant_id);
+}
 
-		outbuf[i] = mxt_get_debug_value(data, rx, ry);
+static ssize_t mxt_show_instance(char *buf, int count,
+				 struct mxt_object *object, int instance,
+				 const u8 *val)
+{
+	int i;
 
-		/* Next value */
-		if (++x >= (data->xy_switch ? data->ysize : data->xsize)) {
-			x = 0;
-			y++;
-		}
-	}
+	if (mxt_obj_instances(object) > 1)
+		count += scnprintf(buf + count, PAGE_SIZE - count,
+				   "Instance %u\n", instance);
 
-	return 0;
+	for (i = 0; i < mxt_obj_size(object); i++)
+		count += scnprintf(buf + count, PAGE_SIZE - count,
+				"\t[%2u]: %02x (%d)\n", i, val[i], val[i]);
+	count += scnprintf(buf + count, PAGE_SIZE - count, "\n");
+
+	return count;
 }
 
-static int mxt_read_diagnostic_debug(struct mxt_data *data, u8 mode,
-				     u16 *outbuf)
+static ssize_t mxt_object_show(struct device *dev,
+				    struct device_attribute *attr, char *buf)
 {
-	struct mxt_dbg *dbg = &data->dbg;
-	int retries = 0;
-	int page;
-	int ret;
-	u8 cmd = mode;
-	struct t37_debug *p;
-	u8 cmd_poll;
+	struct mxt_data *data = dev_get_drvdata(dev);
+	struct mxt_object *object;
+	int count = 0;
+	int i, j;
+	int error;
+	u8 *obuf;
 
-	for (page = 0; page < dbg->t37_pages; page++) {
-		p = dbg->t37_buf + page;
+	/* Pre-allocate buffer large enough to hold max sized object. */
+	obuf = kmalloc(256, GFP_KERNEL);
+	if (!obuf)
+		return -ENOMEM;
 
-		ret = mxt_write_reg(data->client, dbg->diag_cmd_address,
-				    cmd);
-		if (ret)
-			return ret;
+	error = 0;
+	for (i = 0; i < data->info->object_num; i++) {
+		object = data->object_table + i;
 
-		retries = 0;
-		msleep(20);
-wait_cmd:
-		/* Read back command byte */
-		ret = __mxt_read_reg(data->client, dbg->diag_cmd_address,
-				     sizeof(cmd_poll), &cmd_poll);
-		if (ret)
-			return ret;
+		if (!mxt_object_readable(object->type))
+			continue;
 
-		/* Field is cleared once the command has been processed */
-		if (cmd_poll) {
-			if (retries++ > 100)
-				return -EINVAL;
+		count += scnprintf(buf + count, PAGE_SIZE - count,
+				"T%u:\n", object->type);
 
-			msleep(20);
-			goto wait_cmd;
-		}
+		for (j = 0; j < mxt_obj_instances(object); j++) {
+			u16 size = mxt_obj_size(object);
+			u16 addr = object->start_address + j * size;
 
-		/* Read T37 page */
-		ret = __mxt_read_reg(data->client, dbg->t37_address,
-				     sizeof(struct t37_debug), p);
-		if (ret)
-			return ret;
+			error = mxt_read_blks(data, addr, size, obuf);
+			if (error)
+				goto done;
 
-		if (p->mode != mode || p->page != page) {
-			dev_err(&data->client->dev, "T37 page mismatch\n");
-			return -EINVAL;
+			count = mxt_show_instance(buf, count, object, j, obuf);
 		}
-
-		dev_dbg(&data->client->dev, "%s page:%d retries:%d\n",
-			__func__, page, retries);
-
-		/* For remaining pages, write PAGEUP rather than mode */
-		cmd = MXT_DIAGNOSTIC_PAGEUP;
 	}
 
-	return mxt_convert_debug_pages(data, outbuf);
+done:
+	kfree(obuf);
+	return error ?: count;
 }
 
-static int mxt_queue_setup(struct vb2_queue *q,
-		       unsigned int *nbuffers, unsigned int *nplanes,
-		       unsigned int sizes[], struct device *alloc_devs[])
+static int mxt_check_firmware_format(struct device *dev,
+				     const struct firmware *fw)
 {
-	struct mxt_data *data = q->drv_priv;
-	size_t size = data->dbg.t37_nodes * sizeof(u16);
+	unsigned int pos = 0;
+	char c;
 
-	if (*nplanes)
-		return sizes[0] < size ? -EINVAL : 0;
+	while (pos < fw->size) {
+		c = *(fw->data + pos);
 
-	*nplanes = 1;
-	sizes[0] = size;
+		if (c < '0' || (c > '9' && c < 'A') || c > 'F')
+			return 0;
 
-	return 0;
+		pos++;
+	}
+
+	/*
+	 * To convert file try:
+	 * xxd -r -p mXTXXX__APP_VX-X-XX.enc > maxtouch.fw
+	 */
+	dev_err(dev, "Aborting: firmware file must be in binary format\n");
+
+	return -EINVAL;
 }
 
-static void mxt_buffer_queue(struct vb2_buffer *vb)
+static int mxt_enter_bootloader(struct mxt_data *data)
 {
-	struct mxt_data *data = vb2_get_drv_priv(vb->vb2_queue);
-	u16 *ptr;
 	int ret;
-	u8 mode;
 
-	ptr = vb2_plane_vaddr(vb, 0);
-	if (!ptr) {
-		dev_err(&data->client->dev, "Error acquiring frame ptr\n");
-		goto fault;
+	if (data->suspended) {
+		data->suspended = false;
 	}
 
-	switch (data->dbg.input) {
-	case MXT_V4L_INPUT_DELTAS:
-	default:
-		mode = MXT_DIAGNOSTIC_DELTAS;
-		break;
+	if (!data->in_bootloader) {
+		disable_irq(data->irq);
 
-	case MXT_V4L_INPUT_REFS:
-		mode = MXT_DIAGNOSTIC_REFS;
-		break;
-	}
+		/* Change to the bootloader mode */
+		ret = mxt_t6_command(data, MXT_COMMAND_RESET,
+				     MXT_BOOT_VALUE, false);
+		if (ret)
+			return ret;
 
-	ret = mxt_read_diagnostic_debug(data, mode, ptr);
-	if (ret)
-		goto fault;
+		msleep(MXT_RESET_TIME);
 
-	vb2_set_plane_payload(vb, 0, data->dbg.t37_nodes * sizeof(u16));
-	vb2_buffer_done(vb, VB2_BUF_STATE_DONE);
-	return;
+		/* Do not need to scan since we know family ID */
+		ret = mxt_probe_bootloader(data, 0);
+		if (ret)
+			return ret;
 
-fault:
-	vb2_buffer_done(vb, VB2_BUF_STATE_ERROR);
-}
+		data->in_bootloader = true;
+		mxt_debug_msg_remove(data);
+		mxt_sysfs_remove(data);
+		mxt_free_input_device(data);
+		mxt_free_object_table(data);
+	}
 
-/* V4L2 structures */
-static const struct vb2_ops mxt_queue_ops = {
-	.queue_setup		= mxt_queue_setup,
-	.buf_queue		= mxt_buffer_queue,
-	.wait_prepare		= vb2_ops_wait_prepare,
-	.wait_finish		= vb2_ops_wait_finish,
-};
+	dev_dbg(&data->client->dev, "Entered bootloader\n");
 
-static const struct vb2_queue mxt_queue = {
-	.type = V4L2_BUF_TYPE_VIDEO_CAPTURE,
-	.io_modes = VB2_MMAP | VB2_USERPTR | VB2_DMABUF | VB2_READ,
-	.buf_struct_size = sizeof(struct mxt_vb2_buffer),
-	.ops = &mxt_queue_ops,
-	.mem_ops = &vb2_vmalloc_memops,
-	.timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC,
-	.min_buffers_needed = 1,
-};
+	return 0;
+}
 
-static int mxt_vidioc_querycap(struct file *file, void *priv,
-				 struct v4l2_capability *cap)
+static void mxt_fw_work(struct work_struct *work)
 {
-	struct mxt_data *data = video_drvdata(file);
+	struct mxt_flash *f =
+		container_of(work, struct mxt_flash, work.work);
 
-	strlcpy(cap->driver, "atmel_mxt_ts", sizeof(cap->driver));
-	strlcpy(cap->card, "atmel_mxt_ts touch", sizeof(cap->card));
-	snprintf(cap->bus_info, sizeof(cap->bus_info),
-		 "I2C:%s", dev_name(&data->client->dev));
-	return 0;
+	mxt_check_bootloader(f->data);
 }
 
-static int mxt_vidioc_enum_input(struct file *file, void *priv,
-				   struct v4l2_input *i)
+static int mxt_load_fw(struct device *dev)
 {
-	if (i->index >= MXT_V4L_INPUT_MAX)
-		return -EINVAL;
+	struct mxt_data *data = dev_get_drvdata(dev);
+	int ret;
 
-	i->type = V4L2_INPUT_TYPE_TOUCH;
+	data->flash = devm_kzalloc(dev, sizeof(struct mxt_flash), GFP_KERNEL);
+	if (!data->flash)
+		return -ENOMEM;
 
-	switch (i->index) {
-	case MXT_V4L_INPUT_REFS:
-		strlcpy(i->name, "Mutual Capacitance References",
-			sizeof(i->name));
-		break;
-	case MXT_V4L_INPUT_DELTAS:
-		strlcpy(i->name, "Mutual Capacitance Deltas", sizeof(i->name));
-		break;
-	}
+	data->flash->data = data;
 
-	return 0;
-}
+	ret = request_firmware(&data->flash->fw, data->fw_name, dev);
+	if (ret) {
+		dev_err(dev, "Unable to open firmware %s\n", data->fw_name);
+		goto free;
+	}
 
-static int mxt_set_input(struct mxt_data *data, unsigned int i)
-{
-	struct v4l2_pix_format *f = &data->dbg.format;
+	/* Check for incorrect enc file */
+	ret = mxt_check_firmware_format(dev, data->flash->fw);
+	if (ret)
+		goto release_firmware;
 
-	if (i >= MXT_V4L_INPUT_MAX)
-		return -EINVAL;
+	init_completion(&data->flash->flash_completion);
+	INIT_DELAYED_WORK(&data->flash->work, mxt_fw_work);
+	reinit_completion(&data->flash->flash_completion);
 
-	if (i == MXT_V4L_INPUT_DELTAS)
-		f->pixelformat = V4L2_TCH_FMT_DELTA_TD16;
-	else
-		f->pixelformat = V4L2_TCH_FMT_TU16;
+	if (!data->in_bootloader) {
+		ret = mxt_enter_bootloader(data);
+		if (ret)
+			goto release_firmware;
+	}
 
-	f->width = data->xy_switch ? data->ysize : data->xsize;
-	f->height = data->xy_switch ? data->xsize : data->ysize;
-	f->field = V4L2_FIELD_NONE;
-	f->colorspace = V4L2_COLORSPACE_RAW;
-	f->bytesperline = f->width * sizeof(u16);
-	f->sizeimage = f->width * f->height * sizeof(u16);
+	ret = mxt_acquire_irq(data);
+	if (ret)
+		goto release_firmware;
 
-	data->dbg.input = i;
+	/* Poll after 0.1s if no interrupt received */
+	schedule_delayed_work(&data->flash->work, HZ / 10);
 
-	return 0;
-}
+	/* Wait for flash. */
+	ret = mxt_wait_for_completion(data, &data->flash->flash_completion,
+				      MXT_BOOTLOADER_WAIT);
 
-static int mxt_vidioc_s_input(struct file *file, void *priv, unsigned int i)
-{
-	return mxt_set_input(video_drvdata(file), i);
-}
-
-static int mxt_vidioc_g_input(struct file *file, void *priv, unsigned int *i)
-{
-	struct mxt_data *data = video_drvdata(file);
-
-	*i = data->dbg.input;
-
-	return 0;
-}
-
-static int mxt_vidioc_fmt(struct file *file, void *priv, struct v4l2_format *f)
-{
-	struct mxt_data *data = video_drvdata(file);
-
-	f->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-	f->fmt.pix = data->dbg.format;
-
-	return 0;
+	disable_irq(data->irq);
+	cancel_delayed_work_sync(&data->flash->work);
+	data->in_bootloader = false;
+release_firmware:
+	release_firmware(data->flash->fw);
+free:
+	devm_kfree(dev, data->flash);
+	return ret;
 }
 
-static int mxt_vidioc_enum_fmt(struct file *file, void *priv,
-				 struct v4l2_fmtdesc *fmt)
+static int mxt_update_file_name(struct device *dev, char **file_name,
+				const char *buf, size_t count)
 {
-	if (fmt->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
-		return -EINVAL;
+	char *file_name_tmp;
 
-	switch (fmt->index) {
-	case 0:
-		fmt->pixelformat = V4L2_TCH_FMT_TU16;
-		break;
-
-	case 1:
-		fmt->pixelformat = V4L2_TCH_FMT_DELTA_TD16;
-		break;
-
-	default:
+	/* Simple sanity check */
+	if (count > 64) {
+		dev_warn(dev, "File name too long\n");
 		return -EINVAL;
 	}
 
-	return 0;
-}
+	file_name_tmp = krealloc(*file_name, count + 1, GFP_KERNEL);
+	if (!file_name_tmp)
+		return -ENOMEM;
 
-static int mxt_vidioc_g_parm(struct file *file, void *fh,
-			     struct v4l2_streamparm *a)
-{
-	if (a->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
-		return -EINVAL;
+	*file_name = file_name_tmp;
+	memcpy(*file_name, buf, count);
+
+	/* Echo into the sysfs entry may append newline at the end of buf */
+	if (buf[count - 1] == '\n')
+		(*file_name)[count - 1] = '\0';
+	else
+		(*file_name)[count] = '\0';
 
-	a->parm.capture.readbuffers = 1;
-	a->parm.capture.timeperframe.numerator = 1;
-	a->parm.capture.timeperframe.denominator = 10;
 	return 0;
 }
 
-static const struct v4l2_ioctl_ops mxt_video_ioctl_ops = {
-	.vidioc_querycap        = mxt_vidioc_querycap,
-
-	.vidioc_enum_fmt_vid_cap = mxt_vidioc_enum_fmt,
-	.vidioc_s_fmt_vid_cap   = mxt_vidioc_fmt,
-	.vidioc_g_fmt_vid_cap   = mxt_vidioc_fmt,
-	.vidioc_try_fmt_vid_cap	= mxt_vidioc_fmt,
-	.vidioc_g_parm		= mxt_vidioc_g_parm,
-
-	.vidioc_enum_input      = mxt_vidioc_enum_input,
-	.vidioc_g_input         = mxt_vidioc_g_input,
-	.vidioc_s_input         = mxt_vidioc_s_input,
-
-	.vidioc_reqbufs         = vb2_ioctl_reqbufs,
-	.vidioc_create_bufs     = vb2_ioctl_create_bufs,
-	.vidioc_querybuf        = vb2_ioctl_querybuf,
-	.vidioc_qbuf            = vb2_ioctl_qbuf,
-	.vidioc_dqbuf           = vb2_ioctl_dqbuf,
-	.vidioc_expbuf          = vb2_ioctl_expbuf,
-
-	.vidioc_streamon        = vb2_ioctl_streamon,
-	.vidioc_streamoff       = vb2_ioctl_streamoff,
-};
-
-static const struct video_device mxt_video_device = {
-	.name = "Atmel maxTouch",
-	.fops = &mxt_video_fops,
-	.ioctl_ops = &mxt_video_ioctl_ops,
-	.release = video_device_release_empty,
-	.device_caps = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_TOUCH |
-		       V4L2_CAP_READWRITE | V4L2_CAP_STREAMING,
-};
-
-static void mxt_debug_init(struct mxt_data *data)
+static ssize_t mxt_update_fw_store(struct device *dev,
+					struct device_attribute *attr,
+					const char *buf, size_t count)
 {
-	struct mxt_info *info = data->info;
-	struct mxt_dbg *dbg = &data->dbg;
-	struct mxt_object *object;
+	struct mxt_data *data = dev_get_drvdata(dev);
 	int error;
 
-	object = mxt_get_object(data, MXT_GEN_COMMAND_T6);
-	if (!object)
-		goto error;
+	error = mxt_update_file_name(dev, &data->fw_name, buf, count);
+	if (error)
+		return error;
 
-	dbg->diag_cmd_address = object->start_address + MXT_COMMAND_DIAGNOSTIC;
+	error = mxt_load_fw(dev);
+	if (error) {
+		dev_err(dev, "The firmware update failed(%d)\n", error);
+		count = error;
+	} else {
+		dev_info(dev, "The firmware update succeeded\n");
 
-	object = mxt_get_object(data, MXT_DEBUG_DIAGNOSTIC_T37);
-	if (!object)
-		goto error;
+		data->suspended = false;
 
-	if (mxt_obj_size(object) != sizeof(struct t37_debug)) {
-		dev_warn(&data->client->dev, "Bad T37 size");
-		goto error;
+		error = mxt_initialize(data);
+		if (error)
+			return error;
 	}
 
-	dbg->t37_address = object->start_address;
-
-	/* Calculate size of data and allocate buffer */
-	dbg->t37_nodes = data->xsize * data->ysize;
-
-	if (info->family_id == MXT_FAMILY_1386)
-		dbg->t37_pages = MXT1386_COLUMNS * MXT1386_PAGES_PER_COLUMN;
-	else
-		dbg->t37_pages = DIV_ROUND_UP(data->xsize *
-					      info->matrix_ysize *
-					      sizeof(u16),
-					      sizeof(dbg->t37_buf->data));
-
-	dbg->t37_buf = devm_kmalloc_array(&data->client->dev, dbg->t37_pages,
-					  sizeof(struct t37_debug), GFP_KERNEL);
-	if (!dbg->t37_buf)
-		goto error;
-
-	/* init channel to zero */
-	mxt_set_input(data, 0);
-
-	/* register video device */
-	snprintf(dbg->v4l2.name, sizeof(dbg->v4l2.name), "%s", "atmel_mxt_ts");
-	error = v4l2_device_register(&data->client->dev, &dbg->v4l2);
-	if (error)
-		goto error;
-
-	/* initialize the queue */
-	mutex_init(&dbg->lock);
-	dbg->queue = mxt_queue;
-	dbg->queue.drv_priv = data;
-	dbg->queue.lock = &dbg->lock;
-	dbg->queue.dev = &data->client->dev;
-
-	error = vb2_queue_init(&dbg->queue);
-	if (error)
-		goto error_unreg_v4l2;
+	return count;
+}
 
-	dbg->vdev = mxt_video_device;
-	dbg->vdev.v4l2_dev = &dbg->v4l2;
-	dbg->vdev.lock = &dbg->lock;
-	dbg->vdev.vfl_dir = VFL_DIR_RX;
-	dbg->vdev.queue = &dbg->queue;
-	video_set_drvdata(&dbg->vdev, data);
+static ssize_t mxt_update_cfg_store(struct device *dev,
+		struct device_attribute *attr,
+		const char *buf, size_t count)
+{
+	struct mxt_data *data = dev_get_drvdata(dev);
+	const struct mxt_platform_data *pdata = data->pdata;
+	const struct firmware *cfg;
+	int ret;
 
-	error = video_register_device(&dbg->vdev, VFL_TYPE_TOUCH, -1);
-	if (error)
-		goto error_unreg_v4l2;
+	ret = mxt_update_file_name(dev, &data->cfg_name, buf, count);
+	if (ret)
+		return ret;
 
-	return;
+	ret = request_firmware(&cfg, data->cfg_name, dev);
+	if (ret < 0) {
+		dev_err(dev, "Failure to request config file %s\n",
+			data->cfg_name);
+		ret = -ENOENT;
+		goto out;
+	}
 
-error_unreg_v4l2:
-	v4l2_device_unregister(&dbg->v4l2);
-error:
-	dev_warn(&data->client->dev, "Error initializing T37\n");
-}
-#else
-static void mxt_debug_init(struct mxt_data *data)
-{
-}
-#endif
+	data->updating_config = true;
 
-static int mxt_configure_objects(struct mxt_data *data,
-				 const struct firmware *cfg)
-{
-	struct device *dev = &data->client->dev;
-	int error;
+	mxt_free_input_device(data);
 
-	error = mxt_init_t7_power_cfg(data);
-	if (error) {
-		dev_err(dev, "Failed to initialize power cfg\n");
-		return error;
-	}
+	if (data->suspended) {
+		if (pdata->suspend_mode == MXT_SUSPEND_DEEP_SLEEP) {
+			mxt_set_t7_power_cfg(data, MXT_POWER_CFG_RUN);
+			mxt_acquire_irq(data);
+		}
 
-	if (cfg) {
-		error = mxt_update_cfg(data, cfg);
-		if (error)
-			dev_warn(dev, "Error %d updating config\n", error);
+		data->suspended = false;
 	}
 
-	if (data->multitouch) {
-		error = mxt_initialize_input_device(data);
-		if (error)
-			return error;
-	} else {
-		dev_warn(dev, "No touch object detected\n");
-	}
+	ret = mxt_configure_objects(data, cfg);
+	if (ret)
+		goto release;
 
-	mxt_debug_init(data);
+	ret = count;
 
-	return 0;
+release:
+	release_firmware(cfg);
+out:
+	data->updating_config = false;
+	return ret;
 }
 
-/* Firmware Version is returned as Major.Minor.Build */
-static ssize_t mxt_fw_version_show(struct device *dev,
-				   struct device_attribute *attr, char *buf)
+static ssize_t mxt_debug_enable_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
 {
 	struct mxt_data *data = dev_get_drvdata(dev);
-	struct mxt_info *info = data->info;
-	return scnprintf(buf, PAGE_SIZE, "%u.%u.%02X\n",
-			 info->version >> 4, info->version & 0xf, info->build);
+	char c;
+
+	c = data->debug_enabled ? '1' : '0';
+	return scnprintf(buf, PAGE_SIZE, "%c\n", c);
 }
 
-/* Hardware Version is returned as FamilyID.VariantID */
-static ssize_t mxt_hw_version_show(struct device *dev,
-				   struct device_attribute *attr, char *buf)
+static ssize_t mxt_debug_notify_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
 {
-	struct mxt_data *data = dev_get_drvdata(dev);
-	struct mxt_info *info = data->info;
-	return scnprintf(buf, PAGE_SIZE, "%u.%u\n",
-			 info->family_id, info->variant_id);
+	return sprintf(buf, "0\n");
 }
 
-static ssize_t mxt_show_instance(char *buf, int count,
-				 struct mxt_object *object, int instance,
-				 const u8 *val)
+static ssize_t mxt_debug_v2_enable_store(struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t count)
 {
-	int i;
+	struct mxt_data *data = dev_get_drvdata(dev);
+	u8 i;
+	ssize_t ret;
 
-	if (mxt_obj_instances(object) > 1)
-		count += scnprintf(buf + count, PAGE_SIZE - count,
-				   "Instance %u\n", instance);
+	if (kstrtou8(buf, 0, &i) == 0 && i < 2) {
+		if (i == 1)
+			mxt_debug_msg_enable(data);
+		else
+			mxt_debug_msg_disable(data);
 
-	for (i = 0; i < mxt_obj_size(object); i++)
-		count += scnprintf(buf + count, PAGE_SIZE - count,
-				"\t[%2u]: %02x (%d)\n", i, val[i], val[i]);
-	count += scnprintf(buf + count, PAGE_SIZE - count, "\n");
+		ret = count;
+	} else {
+		dev_dbg(dev, "debug_enabled write error\n");
+		ret = -EINVAL;
+	}
 
-	return count;
+	return ret;
 }
 
-static ssize_t mxt_object_show(struct device *dev,
-				    struct device_attribute *attr, char *buf)
+static ssize_t mxt_debug_enable_store(struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t count)
 {
 	struct mxt_data *data = dev_get_drvdata(dev);
-	struct mxt_object *object;
-	int count = 0;
-	int i, j;
-	int error;
-	u8 *obuf;
-
-	/* Pre-allocate buffer large enough to hold max sized object. */
-	obuf = kmalloc(256, GFP_KERNEL);
-	if (!obuf)
-		return -ENOMEM;
+	u8 i;
+	ssize_t ret;
 
-	error = 0;
-	for (i = 0; i < data->info->object_num; i++) {
-		object = data->object_table + i;
+	if (kstrtou8(buf, 0, &i) == 0 && i < 2) {
+		data->debug_enabled = (i == 1);
 
-		if (!mxt_object_readable(object->type))
-			continue;
-
-		count += scnprintf(buf + count, PAGE_SIZE - count,
-				"T%u:\n", object->type);
-
-		for (j = 0; j < mxt_obj_instances(object); j++) {
-			u16 size = mxt_obj_size(object);
-			u16 addr = object->start_address + j * size;
-
-			error = mxt_read_blks(data, addr, size, obuf);
-			if (error)
-				goto done;
-
-			count = mxt_show_instance(buf, count, object, j, obuf);
-		}
+		dev_dbg(dev, "%s\n", i ? "debug enabled" : "debug disabled");
+		ret = count;
+	} else {
+		dev_dbg(dev, "debug_enabled write error\n");
+		ret = -EINVAL;
 	}
 
-done:
-	kfree(obuf);
-	return error ?: count;
+	return ret;
 }
 
-static int mxt_check_firmware_format(struct device *dev,
-				     const struct firmware *fw)
+static int mxt_check_mem_access_params(struct mxt_data *data, loff_t off,
+				       size_t *count)
 {
-	unsigned int pos = 0;
-	char c;
+	if (off >= data->mem_size)
+		return -EIO;
 
-	while (pos < fw->size) {
-		c = *(fw->data + pos);
+	if (off + *count > data->mem_size)
+		*count = data->mem_size - off;
 
-		if (c < '0' || (c > '9' && c < 'A') || c > 'F')
-			return 0;
+	if (*count > MXT_MAX_BLOCK_WRITE)
+		*count = MXT_MAX_BLOCK_WRITE;
 
-		pos++;
-	}
-
-	/*
-	 * To convert file try:
-	 * xxd -r -p mXTXXX__APP_VX-X-XX.enc > maxtouch.fw
-	 */
-	dev_err(dev, "Aborting: firmware file must be in binary format\n");
-
-	return -EINVAL;
+	return 0;
 }
 
-static int mxt_load_fw(struct device *dev, const char *fn)
+static ssize_t mxt_mem_access_read(struct file *filp, struct kobject *kobj,
+	struct bin_attribute *bin_attr, char *buf, loff_t off, size_t count)
 {
+	struct device *dev = container_of(kobj, struct device, kobj);
 	struct mxt_data *data = dev_get_drvdata(dev);
-	const struct firmware *fw = NULL;
-	unsigned int frame_size;
-	unsigned int pos = 0;
-	unsigned int retry = 0;
-	unsigned int frame = 0;
-	int ret;
+	int ret = 0;
 
-	ret = request_firmware(&fw, fn, dev);
-	if (ret) {
-		dev_err(dev, "Unable to open firmware %s\n", fn);
+	ret = mxt_check_mem_access_params(data, off, &count);
+	if (ret < 0)
 		return ret;
-	}
-
-	/* Check for incorrect enc file */
-	ret = mxt_check_firmware_format(dev, fw);
-	if (ret)
-		goto release_firmware;
-
-	if (data->suspended) {
-		if (data->suspend_mode == MXT_SUSPEND_DEEP_SLEEP)
-			enable_irq(data->irq);
 
-		data->suspended = false;
-	}
+	if (count > 0)
+		ret = __mxt_read_reg(data->client, off, count, buf);
 
-	if (!data->in_bootloader) {
-		/* Change to the bootloader mode */
-		data->in_bootloader = true;
-
-		ret = mxt_t6_command(data, MXT_COMMAND_RESET,
-				     MXT_BOOT_VALUE, false);
-		if (ret)
-			goto release_firmware;
-
-		msleep(MXT_RESET_TIME);
-
-		/* Do not need to scan since we know family ID */
-		ret = mxt_lookup_bootloader_address(data, 0);
-		if (ret)
-			goto release_firmware;
-
-		mxt_free_input_device(data);
-		mxt_free_object_table(data);
-	} else {
-		mxt_acquire_irq(data);
-	}
-
-	reinit_completion(&data->chg_completion);
-
-	ret = mxt_check_bootloader(data, MXT_WAITING_BOOTLOAD_CMD, false);
-	if (ret) {
-		/* Bootloader may still be unlocked from previous attempt */
-		ret = mxt_check_bootloader(data, MXT_WAITING_FRAME_DATA, false);
-		if (ret)
-			goto disable_irq;
-	} else {
-		dev_info(dev, "Unlocking bootloader\n");
-
-		/* Unlock bootloader */
-		ret = mxt_send_bootloader_cmd(data, true);
-		if (ret)
-			goto disable_irq;
-	}
-
-	while (pos < fw->size) {
-		ret = mxt_check_bootloader(data, MXT_WAITING_FRAME_DATA, true);
-		if (ret)
-			goto disable_irq;
-
-		frame_size = ((*(fw->data + pos) << 8) | *(fw->data + pos + 1));
-
-		/* Take account of CRC bytes */
-		frame_size += 2;
-
-		/* Write one frame to device */
-		ret = mxt_bootloader_write(data, fw->data + pos, frame_size);
-		if (ret)
-			goto disable_irq;
-
-		ret = mxt_check_bootloader(data, MXT_FRAME_CRC_PASS, true);
-		if (ret) {
-			retry++;
-
-			/* Back off by 20ms per retry */
-			msleep(retry * 20);
-
-			if (retry > 20) {
-				dev_err(dev, "Retry count exceeded\n");
-				goto disable_irq;
-			}
-		} else {
-			retry = 0;
-			pos += frame_size;
-			frame++;
-		}
-
-		if (frame % 50 == 0)
-			dev_dbg(dev, "Sent %d frames, %d/%zd bytes\n",
-				frame, pos, fw->size);
-	}
-
-	/* Wait for flash. */
-	ret = mxt_wait_for_completion(data, &data->chg_completion,
-				      MXT_FW_RESET_TIME);
-	if (ret)
-		goto disable_irq;
-
-	dev_dbg(dev, "Sent %d frames, %d bytes\n", frame, pos);
-
-	/*
-	 * Wait for device to reset. Some bootloader versions do not assert
-	 * the CHG line after bootloading has finished, so ignore potential
-	 * errors.
-	 */
-	mxt_wait_for_completion(data, &data->chg_completion, MXT_FW_RESET_TIME);
-
-	data->in_bootloader = false;
-
-disable_irq:
-	disable_irq(data->irq);
-release_firmware:
-	release_firmware(fw);
-	return ret;
+	return ret == 0 ? count : ret;
 }
 
-static ssize_t mxt_update_fw_store(struct device *dev,
-					struct device_attribute *attr,
-					const char *buf, size_t count)
+static ssize_t mxt_mem_access_write(struct file *filp, struct kobject *kobj,
+	struct bin_attribute *bin_attr, char *buf, loff_t off,
+	size_t count)
 {
+	struct device *dev = container_of(kobj, struct device, kobj);
 	struct mxt_data *data = dev_get_drvdata(dev);
-	int error;
-
-	error = mxt_load_fw(dev, MXT_FW_NAME);
-	if (error) {
-		dev_err(dev, "The firmware update failed(%d)\n", error);
-		count = error;
-	} else {
-		dev_info(dev, "The firmware update succeeded\n");
+	int ret = 0;
 
-		data->suspended = false;
+	ret = mxt_check_mem_access_params(data, off, &count);
+	if (ret < 0)
+		return ret;
 
-		error = mxt_initialize(data);
-		if (error)
-			return error;
-	}
+	if (count > 0)
+		ret = __mxt_write_reg(data->client, off, count, buf);
 
-	return count;
+	return ret == 0 ? count : ret;
 }
 
+static DEVICE_ATTR(update_fw, S_IWUSR, NULL, mxt_update_fw_store);
+
+static struct attribute *mxt_fw_attrs[] = {
+	&dev_attr_update_fw.attr,
+	NULL
+};
+
+static const struct attribute_group mxt_fw_attr_group = {
+	.attrs = mxt_fw_attrs,
+};
+
 static DEVICE_ATTR(fw_version, S_IRUGO, mxt_fw_version_show, NULL);
 static DEVICE_ATTR(hw_version, S_IRUGO, mxt_hw_version_show, NULL);
 static DEVICE_ATTR(object, S_IRUGO, mxt_object_show, NULL);
-static DEVICE_ATTR(update_fw, S_IWUSR, NULL, mxt_update_fw_store);
+static DEVICE_ATTR(update_cfg, S_IWUSR, NULL, mxt_update_cfg_store);
+static DEVICE_ATTR(config_crc, S_IRUGO, mxt_config_crc_show, NULL);
+static DEVICE_ATTR(debug_enable, S_IWUSR | S_IRUSR, mxt_debug_enable_show,
+		   mxt_debug_enable_store);
+static DEVICE_ATTR(debug_v2_enable, S_IWUSR | S_IRUSR, NULL,
+		   mxt_debug_v2_enable_store);
+static DEVICE_ATTR(debug_notify, S_IRUGO, mxt_debug_notify_show, NULL);
 
 static struct attribute *mxt_attrs[] = {
 	&dev_attr_fw_version.attr,
 	&dev_attr_hw_version.attr,
 	&dev_attr_object.attr,
-	&dev_attr_update_fw.attr,
+	&dev_attr_update_cfg.attr,
+	&dev_attr_config_crc.attr,
+	&dev_attr_debug_enable.attr,
+	&dev_attr_debug_v2_enable.attr,
+	&dev_attr_debug_notify.attr,
 	NULL
 };
 
@@ -3064,6 +3261,51 @@ static const struct attribute_group mxt_attr_group = {
 	.attrs = mxt_attrs,
 };
 
+static int mxt_sysfs_init(struct mxt_data *data)
+{
+	struct i2c_client *client = data->client;
+	int error;
+
+	error = sysfs_create_group(&client->dev.kobj, &mxt_attr_group);
+	if (error) {
+		dev_err(&client->dev, "Failure %d creating sysfs group\n",
+			error);
+		return error;
+	}
+
+	sysfs_bin_attr_init(&data->mem_access_attr);
+	data->mem_access_attr.attr.name = "mem_access";
+	data->mem_access_attr.attr.mode = S_IRUGO | S_IWUSR;
+	data->mem_access_attr.read = mxt_mem_access_read;
+	data->mem_access_attr.write = mxt_mem_access_write;
+	data->mem_access_attr.size = data->mem_size;
+
+	error = sysfs_create_bin_file(&client->dev.kobj,
+				  &data->mem_access_attr);
+	if (error) {
+		dev_err(&client->dev, "Failed to create %s\n",
+			data->mem_access_attr.attr.name);
+		goto err_remove_sysfs_group;
+	}
+
+	return 0;
+
+err_remove_sysfs_group:
+	sysfs_remove_group(&client->dev.kobj, &mxt_attr_group);
+	return error;
+}
+
+static void mxt_sysfs_remove(struct mxt_data *data)
+{
+	struct i2c_client *client = data->client;
+
+	if (data->mem_access_attr.attr.name)
+		sysfs_remove_bin_file(&client->dev.kobj,
+				      &data->mem_access_attr);
+
+	sysfs_remove_group(&client->dev.kobj, &mxt_attr_group);
+}
+
 static void mxt_reset_slots(struct mxt_data *data)
 {
 	struct input_dev *input_dev = data->input_dev;
@@ -3074,7 +3316,7 @@ static void mxt_reset_slots(struct mxt_data *data)
 
 	for (id = 0; id < data->num_touchids; id++) {
 		input_mt_slot(input_dev, id);
-		input_mt_report_slot_state(input_dev, MT_TOOL_FINGER, 0);
+		input_mt_report_slot_state(input_dev, 0, 0);
 	}
 
 	mxt_input_sync(data);
@@ -3089,7 +3331,7 @@ static int mxt_start(struct mxt_data *data)
 
 	mxt_wakeup_toggle(data->client, true, false);
 	
-	switch (data->suspend_mode) {
+	switch (data->pdata->suspend_mode) {
 	case MXT_SUSPEND_T9_CTRL:
 		mxt_soft_reset(data);
 
@@ -3132,10 +3374,10 @@ static int mxt_stop(struct mxt_data *data)
 {
 	int ret;
 
-	if (data->suspended || data->in_bootloader)
+	if (data->suspended || data->in_bootloader || data->updating_config)
 		return 0;
 
-	switch (data->suspend_mode) {
+	switch (data->pdata->suspend_mode) {
 	case MXT_SUSPEND_T9_CTRL:
 		/* Touch disable */
 		ret = mxt_write_object(data,
@@ -3187,74 +3429,138 @@ static void mxt_input_close(struct input_dev *dev)
 		dev_err(&data->client->dev, "%s failed rc=%d\n", __func__, ret);
 }
 
-static int mxt_parse_device_properties(struct mxt_data *data)
+#ifdef CONFIG_OF
+static const struct mxt_platform_data *mxt_parse_dt(struct i2c_client *client)
 {
-	static const char keymap_property[] = "linux,gpio-keymap";
-	struct device *dev = &data->client->dev;
+	struct mxt_platform_data *pdata;
+	struct device_node *np = client->dev.of_node;
 	u32 *keymap;
-	int n_keys;
-	int error;
+	int proplen, ret;
 
-	if (device_property_present(dev, keymap_property)) {
-		n_keys = device_property_count_u32(dev, keymap_property);
-		if (n_keys <= 0) {
-			error = n_keys < 0 ? n_keys : -EINVAL;
-			dev_err(dev, "invalid/malformed '%s' property: %d\n",
-				keymap_property, error);
-			return error;
-		}
+	if (!np)
+		return ERR_PTR(-ENOENT);
+
+	pdata = devm_kzalloc(&client->dev, sizeof(*pdata), GFP_KERNEL);
+	if (!pdata)
+		return ERR_PTR(-ENOMEM);
+
+	pdata->gpio_reset = of_get_named_gpio_flags(np, "atmel,reset-gpio",
+						    0, NULL);
 
-		keymap = devm_kmalloc_array(dev, n_keys, sizeof(*keymap),
-					    GFP_KERNEL);
+	of_property_read_string(np, "atmel,cfg_name", &pdata->cfg_name);
+
+	of_property_read_string(np, "atmel,input_name", &pdata->input_name);
+
+	if (of_find_property(np, "linux,gpio-keymap", &proplen)) {
+		pdata->t19_num_keys = proplen / sizeof(u32);
+
+		keymap = devm_kzalloc(&client->dev,
+				pdata->t19_num_keys * sizeof(keymap[0]),
+				GFP_KERNEL);
 		if (!keymap)
-			return -ENOMEM;
+			return ERR_PTR(-ENOMEM);
 
-		error = device_property_read_u32_array(dev, keymap_property,
-						       keymap, n_keys);
-		if (error) {
-			dev_err(dev, "failed to parse '%s' property: %d\n",
-				keymap_property, error);
-			return error;
-		}
+		ret = of_property_read_u32_array(np, "linux,gpio-keymap",
+						 keymap, pdata->t19_num_keys);
+		if (ret)
+			dev_warn(&client->dev,
+				 "Couldn't read linux,gpio-keymap: %d\n", ret);
 
-		data->t19_keymap = keymap;
-		data->t19_num_keys = n_keys;
+		pdata->t19_keymap = keymap;
 	}
 
-	return 0;
+	of_property_read_u32(np, "atmel,suspend-mode", &pdata->suspend_mode);
+
+	return pdata;
+}
+#else
+static const struct mxt_platform_data *mxt_parse_dt(struct i2c_client *client)
+{
+	return ERR_PTR(-ENOENT);
 }
+#endif
 
-static const struct dmi_system_id chromebook_T9_suspend_dmi[] = {
+#ifdef CONFIG_ACPI
+
+struct mxt_acpi_platform_data {
+	const char *hid;
+	struct mxt_platform_data pdata;
+};
+
+static unsigned int samus_touchpad_buttons[] = {
+	KEY_RESERVED,
+	KEY_RESERVED,
+	KEY_RESERVED,
+	BTN_LEFT
+};
+
+static struct mxt_acpi_platform_data samus_platform_data[] = {
+	{
+		/* Touchpad */
+		.hid	= "ATML0000",
+		.pdata	= {
+			.t19_num_keys	= ARRAY_SIZE(samus_touchpad_buttons),
+			.t19_keymap	= samus_touchpad_buttons,
+		},
+	},
+	{
+		/* Touchscreen */
+		.hid	= "ATML0001",
+	},
+	{ }
+};
+
+static unsigned int chromebook_tp_buttons[] = {
+	KEY_RESERVED,
+	KEY_RESERVED,
+	KEY_RESERVED,
+	KEY_RESERVED,
+	KEY_RESERVED,
+	BTN_LEFT
+};
+
+static struct mxt_acpi_platform_data chromebook_platform_data[] = {
 	{
+		/* Touchpad */
+		.hid	= "ATML0000",
+		.pdata	= {
+			.t19_num_keys	= ARRAY_SIZE(chromebook_tp_buttons),
+			.t19_keymap	= chromebook_tp_buttons,
+		},
+	},
+	{
+		/* Touchscreen */
+		.hid	= "ATML0001",
+	},
+	{ }
+};
+
+static const struct dmi_system_id mxt_dmi_table[] = {
+	{
+		/* 2015 Google Pixel */
+		.ident = "Chromebook Pixel 2",
 		.matches = {
 			DMI_MATCH(DMI_SYS_VENDOR, "GOOGLE"),
-			DMI_MATCH(DMI_PRODUCT_NAME, "Link"),
+			DMI_MATCH(DMI_PRODUCT_NAME, "Samus"),
 		},
+		.driver_data = samus_platform_data,
 	},
 	{
+		/* Other Google Chromebooks */
+		.ident = "Chromebook",
 		.matches = {
-			DMI_MATCH(DMI_PRODUCT_NAME, "Peppy"),
+			DMI_MATCH(DMI_SYS_VENDOR, "GOOGLE"),
 		},
+		.driver_data = chromebook_platform_data,
 	},
 	{ }
 };
 
-static int mxt_probe(struct i2c_client *client, const struct i2c_device_id *id)
+static const struct mxt_platform_data *mxt_parse_acpi(struct i2c_client *client)
 {
-	struct mxt_data *data;
-	int error;
-
-	/*
-	 * Ignore devices that do not have device properties attached to
-	 * them, as we need help determining whether we are dealing with
-	 * touch screen or touchpad.
-	 *
-	 * So far on x86 the only users of Atmel touch controllers are
-	 * Chromebooks, and chromeos_laptop driver will ensure that
-	 * necessary properties are provided (if firmware does not do that).
-	 */
-	if (!device_property_present(&client->dev, "compatible"))
-		return -ENXIO;
+	struct acpi_device *adev;
+	const struct dmi_system_id *system_id;
+	const struct mxt_acpi_platform_data *acpi_pdata;
 
 	/*
 	 * Ignore ACPI devices representing bootloader mode.
@@ -3266,8 +3572,85 @@ static int mxt_probe(struct i2c_client *client, const struct i2c_device_id *id)
 	 * application mode addresses were all above 0x40, so we'll use it
 	 * as a threshold.
 	 */
-	if (ACPI_COMPANION(&client->dev) && client->addr < 0x40)
-		return -ENXIO;
+	if (client->addr < 0x40)
+		return ERR_PTR(-ENXIO);
+
+	adev = ACPI_COMPANION(&client->dev);
+	if (!adev)
+		return ERR_PTR(-ENOENT);
+
+	system_id = dmi_first_match(mxt_dmi_table);
+	if (!system_id)
+		return ERR_PTR(-ENOENT);
+
+	acpi_pdata = system_id->driver_data;
+	if (!acpi_pdata)
+		return ERR_PTR(-ENOENT);
+
+	while (acpi_pdata->hid) {
+		if (!strcmp(acpi_device_hid(adev), acpi_pdata->hid))
+			return &acpi_pdata->pdata;
+
+		acpi_pdata++;
+	}
+
+	return ERR_PTR(-ENOENT);
+}
+#else
+static const struct mxt_platform_data *mxt_parse_acpi(struct i2c_client *client)
+{
+	return ERR_PTR(-ENOENT);
+}
+#endif
+
+static struct mxt_platform_data *mxt_default_pdata(struct i2c_client *client)
+{
+	struct mxt_platform_data *pdata;
+
+	pdata = devm_kzalloc(&client->dev, sizeof(*pdata), GFP_KERNEL);
+	if (!pdata)
+		return ERR_PTR(-ENOMEM);
+
+	/* Set default parameters */
+	pdata->irqflags = IRQF_TRIGGER_FALLING;
+
+	return pdata;
+}
+
+static const struct mxt_platform_data *
+mxt_get_platform_data(struct i2c_client *client)
+{
+	const struct mxt_platform_data *pdata;
+
+	pdata = dev_get_platdata(&client->dev);
+	if (pdata)
+		return pdata;
+
+	pdata = mxt_parse_dt(client);
+	if (!IS_ERR(pdata) || PTR_ERR(pdata) != -ENOENT)
+		return pdata;
+
+	pdata = mxt_parse_acpi(client);
+	if (!IS_ERR(pdata) || PTR_ERR(pdata) != -ENOENT)
+		return pdata;
+
+	pdata = mxt_default_pdata(client);
+	if (!IS_ERR(pdata))
+		return pdata;
+
+	dev_err(&client->dev, "No platform data specified\n");
+	return ERR_PTR(-EINVAL);
+}
+
+static int mxt_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{
+	struct mxt_data *data;
+	const struct mxt_platform_data *pdata;
+	int error;
+
+	pdata = mxt_get_platform_data(client);
+	if (IS_ERR(pdata))
+		return PTR_ERR(pdata);
 
 	data = devm_kzalloc(&client->dev, sizeof(struct mxt_data), GFP_KERNEL);
 	if (!data)
@@ -3277,18 +3660,19 @@ static int mxt_probe(struct i2c_client *client, const struct i2c_device_id *id)
 		 client->adapter->nr, client->addr);
 
 	data->client = client;
+	data->pdata = pdata;
 	i2c_set_clientdata(client, data);
 
+	if (data->pdata->cfg_name)
+		mxt_update_file_name(&data->client->dev,
+				     &data->cfg_name,
+				     data->pdata->cfg_name,
+				     strlen(data->pdata->cfg_name));
+
 	init_completion(&data->chg_completion);
 	init_completion(&data->reset_completion);
 	init_completion(&data->crc_completion);
-
-	data->suspend_mode = dmi_check_system(chromebook_T9_suspend_dmi) ?
-		MXT_SUSPEND_T9_CTRL : MXT_SUSPEND_DEEP_SLEEP;
-
-	error = mxt_parse_device_properties(data);
-	if (error)
-		return error;
+	mutex_init(&data->debug_msg_lock);
 
 	/*
 	 * VDDA is the analog voltage supply 2.57..3.47 V
@@ -3337,10 +3721,15 @@ static int mxt_probe(struct i2c_client *client, const struct i2c_device_id *id)
 	msleep(MXT_BACKUP_TIME);
 
 	if (data->reset_gpio) {
-		/* Wait a while and then de-assert the RESET GPIO line */
-		msleep(MXT_RESET_GPIO_TIME);
+		data->in_bootloader = true;
+		msleep(MXT_RESET_TIME);
+		reinit_completion(&data->chg_completion);
 		gpiod_set_value(data->reset_gpio, 0);
-		msleep(MXT_RESET_INVALID_CHG);
+		error = mxt_wait_for_completion(data, &data->chg_completion,
+						MXT_RESET_TIMEOUT);
+		if (error)
+			return error;
+		data->in_bootloader = false;
 	}
 
 	/*
@@ -3372,9 +3761,9 @@ static int mxt_probe(struct i2c_client *client, const struct i2c_device_id *id)
 			goto err_disable_regulators;
 	}
 
-	error = sysfs_create_group(&client->dev.kobj, &mxt_attr_group);
+	error = sysfs_create_group(&client->dev.kobj, &mxt_fw_attr_group);
 	if (error) {
-		dev_err(&client->dev, "Failure %d creating sysfs group\n",
+		dev_err(&client->dev, "Failure %d creating fw sysfs group\n",
 			error);
 		goto err_free_object;
 	}
@@ -3395,7 +3784,10 @@ static int mxt_remove(struct i2c_client *client)
 	struct mxt_data *data = i2c_get_clientdata(client);
 
 	disable_irq(data->irq);
-	sysfs_remove_group(&client->dev.kobj, &mxt_attr_group);
+	sysfs_remove_group(&client->dev.kobj, &mxt_fw_attr_group);
+	mxt_debug_msg_remove(data);
+	mxt_sysfs_remove(data);
+
 	mxt_free_input_device(data);
 	mxt_free_object_table(data);
 	regulator_bulk_disable(ARRAY_SIZE(data->regulators),
@@ -3450,11 +3842,6 @@ static SIMPLE_DEV_PM_OPS(mxt_pm_ops, mxt_suspend, mxt_resume);
 
 static const struct of_device_id mxt_of_match[] = {
 	{ .compatible = "atmel,maxtouch", },
-	/* Compatibles listed below are deprecated */
-	{ .compatible = "atmel,qt602240_ts", },
-	{ .compatible = "atmel,atmel_mxt_ts", },
-	{ .compatible = "atmel,atmel_mxt_tp", },
-	{ .compatible = "atmel,mXT224", },
 	{},
 };
 MODULE_DEVICE_TABLE(of, mxt_of_match);
@@ -3481,7 +3868,8 @@ MODULE_DEVICE_TABLE(i2c, mxt_id);
 static struct i2c_driver mxt_driver = {
 	.driver = {
 		.name	= "atmel_mxt_ts",
-		.of_match_table = mxt_of_match,
+		.owner	= THIS_MODULE,
+		.of_match_table = of_match_ptr(mxt_of_match),
 		.acpi_match_table = ACPI_PTR(mxt_acpi_id),
 		.pm	= &mxt_pm_ops,
 	},
diff --git a/include/dt-bindings/input/atmel_mxt_ts.h b/include/dt-bindings/input/atmel_mxt_ts.h
new file mode 100644
index 000000000000..e4c4c0f6fa37
--- /dev/null
+++ b/include/dt-bindings/input/atmel_mxt_ts.h
@@ -0,0 +1,22 @@
+/*
+ * Atmel maXTouch Touchscreen driver
+ *
+ * Copyright (C) 2015 Atmel Corporation
+ * Author: Nick Dyer <nick.dyer@itdev.co.uk>
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#ifndef __DT_BINDINGS_ATMEL_MXT_TS_H
+#define __DT_BINDINGS_ATMEL_MXT_TS_H
+
+enum mxt_suspend_mode {
+	MXT_SUSPEND_DEEP_SLEEP = 0,
+	MXT_SUSPEND_T9_CTRL = 1,
+	MXT_SUSPEND_REGULATOR = 2,
+};
+
+#endif /* __DT_BINDINGS_ATMEL_MXT_TS_H */
diff --git a/include/linux/platform_data/atmel_mxt_ts.h b/include/linux/platform_data/atmel_mxt_ts.h
index 9d4ddbf4ee31..be6fa95a6613 100644
--- a/include/linux/platform_data/atmel_mxt_ts.h
+++ b/include/linux/platform_data/atmel_mxt_ts.h
@@ -22,7 +22,11 @@ struct mxt_platform_data {
 	u8 t19_num_keys;
 	const unsigned int *t19_keymap;
 	enum mxt_suspend_mode suspend_mode;
+	int t15_num_keys;
+	const unsigned int *t15_keymap;
 	unsigned long gpio_reset;
+	const char *cfg_name;
+	const char *input_name;
 };
 
 #endif /* __LINUX_PLATFORM_DATA_ATMEL_MXT_TS_H */
-- 
2.34.1


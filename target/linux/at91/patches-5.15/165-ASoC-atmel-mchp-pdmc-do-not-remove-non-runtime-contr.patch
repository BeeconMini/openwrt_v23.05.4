From 5ddf43b1270b5a1a9640358a9c71d58317634b02 Mon Sep 17 00:00:00 2001
From: Codrin Ciubotariu <codrin.ciubotariu@microchip.com>
Date: Mon, 14 Mar 2022 10:13:59 +0200
Subject: [PATCH 056/471] ASoC: atmel: mchp-pdmc: do not remove non-runtime
 controls

Removing controls causes issues if the stream is started from another
control. Do not remove these controls when the stream is
started/finished and make it return -EBUSY instead. The controller is
considered busy when the audio filter and the SINC filter are used.

Signed-off-by: Codrin Ciubotariu <codrin.ciubotariu@microchip.com>
---
 sound/soc/atmel/mchp-pdmc.c | 84 +++++++++++++++----------------------
 1 file changed, 34 insertions(+), 50 deletions(-)

diff --git a/sound/soc/atmel/mchp-pdmc.c b/sound/soc/atmel/mchp-pdmc.c
index 1a7802fbf23c..b72c854bbeff 100644
--- a/sound/soc/atmel/mchp-pdmc.c
+++ b/sound/soc/atmel/mchp-pdmc.c
@@ -12,6 +12,7 @@
 #include <linux/module.h>
 #include <linux/of.h>
 #include <linux/regmap.h>
+#include <linux/spinlock.h>
 
 #include <sound/core.h>
 #include <sound/dmaengine_pcm.h>
@@ -106,6 +107,7 @@ struct mchp_pdmc_chmap {
 
 struct mchp_pdmc {
 	struct mic_map channel_mic_map[MCHP_PDMC_MAX_CHANNELS];
+	spinlock_t busy_lock;		/* lock protecting busy */
 	struct device *dev;
 	struct snd_dmaengine_dai_dma_data addr;
 	struct regmap *regmap;
@@ -116,6 +118,7 @@ struct mchp_pdmc {
 	int sinc_order;
 	bool audio_filter_en;
 	u8 gclk_enabled:1;
+	u8 busy:1;
 };
 
 static const char *const mchp_pdmc_sinc_filter_order_text[] = {
@@ -141,6 +144,7 @@ static int mchp_pdmc_sinc_order_get(struct snd_kcontrol *kcontrol,
 	unsigned int item;
 
 	item = snd_soc_enum_val_to_item(e, dd->sinc_order);
+
 	uvalue->value.enumerated.item[0] = item;
 
 	return 0;
@@ -159,10 +163,19 @@ static int mchp_pdmc_sinc_order_put(struct snd_kcontrol *kcontrol,
 		return -EINVAL;
 
 	val = snd_soc_enum_item_to_val(e, item[0]) << e->shift_l;
-	if (val == dd->sinc_order)
+
+	spin_lock(&dd->busy_lock);
+	if (dd->busy) {
+		spin_unlock((&dd->busy_lock));
+		return -EBUSY;
+	}
+	if (val == dd->sinc_order) {
+		spin_unlock((&dd->busy_lock));
 		return 0;
+	}
 
 	dd->sinc_order = val;
+	spin_unlock((&dd->busy_lock));
 
 	return 1;
 }
@@ -185,10 +198,18 @@ static int mchp_pdmc_af_put(struct snd_kcontrol *kcontrol,
 	struct mchp_pdmc *dd = snd_soc_component_get_drvdata(component);
 	bool af = uvalue->value.integer.value[0] ? true : false;
 
-	if (dd->audio_filter_en == af)
+	spin_lock(&dd->busy_lock);
+	if (dd->busy) {
+		spin_unlock((&dd->busy_lock));
+		return -EBUSY;
+	}
+	if (dd->audio_filter_en == af) {
+		spin_unlock((&dd->busy_lock));
 		return 0;
+	}
 
 	dd->audio_filter_en = af;
+	spin_unlock((&dd->busy_lock));
 
 	return 1;
 }
@@ -371,58 +392,10 @@ static const struct snd_kcontrol_new mchp_pdmc_snd_controls[] = {
 	},
 };
 
-static int mchp_pdmc_close(struct snd_soc_component *component,
-			   struct snd_pcm_substream *substream)
-{
-	return snd_soc_add_component_controls(component, mchp_pdmc_snd_controls,
-					      ARRAY_SIZE(mchp_pdmc_snd_controls));
-}
-
-static int mchp_pdmc_open(struct snd_soc_component *component,
-			  struct snd_pcm_substream *substream)
-{
-	int i;
-
-	/* remove controls that can't be changed at runtime */
-	for (i = 0; i < ARRAY_SIZE(mchp_pdmc_snd_controls); i++) {
-		const struct snd_kcontrol_new *control = &mchp_pdmc_snd_controls[i];
-		struct snd_ctl_elem_id id;
-		struct snd_kcontrol *kctl;
-		int err;
-
-		if (component->name_prefix)
-			snprintf(id.name, sizeof(id.name), "%s %s", component->name_prefix,
-				 control->name);
-		else
-			strscpy(id.name, control->name, sizeof(id.name));
-
-		id.numid = 0;
-		id.iface = control->iface;
-		id.device = control->device;
-		id.subdevice = control->subdevice;
-		id.index = control->index;
-		kctl = snd_ctl_find_id(component->card->snd_card, &id);
-		if (!kctl) {
-			dev_err(component->dev, "Failed to find %s\n", control->name);
-			continue;
-		}
-		err = snd_ctl_remove(component->card->snd_card, kctl);
-		if (err < 0) {
-			dev_err(component->dev, "%d: Failed to remove %s\n", err,
-				control->name);
-			continue;
-		}
-	}
-
-	return 0;
-}
-
 static const struct snd_soc_component_driver mchp_pdmc_dai_component = {
 	.name = "mchp-pdmc",
 	.controls = mchp_pdmc_snd_controls,
 	.num_controls = ARRAY_SIZE(mchp_pdmc_snd_controls),
-	.open = &mchp_pdmc_open,
-	.close = &mchp_pdmc_close,
 };
 
 static const unsigned int mchp_pdmc_1mic[] = {1};
@@ -598,6 +571,13 @@ static int mchp_pdmc_hw_params(struct snd_pcm_substream *substream,
 		dd->gclk_enabled = 0;
 	}
 
+	/*
+	 * from these point forward, we consider the controller busy, so the
+	 * audio filter and SINC order can't be changed
+	 */
+	spin_lock(&dd->busy_lock);
+	dd->busy = 1;
+	spin_unlock((&dd->busy_lock));
 	for (osr_start = dd->audio_filter_en ? 64 : 8;
 	     osr_start <= 256 && best_diff_rate; osr_start *= 2) {
 		long round_rate;
@@ -654,6 +634,9 @@ static int mchp_pdmc_hw_free(struct snd_pcm_substream *substream,
 {
 	struct mchp_pdmc *dd = snd_soc_dai_get_drvdata(dai);
 
+	spin_lock(&dd->busy_lock);
+	dd->busy = 0;
+	spin_unlock((&dd->busy_lock));
 	if (dd->gclk_enabled) {
 		clk_disable_unprepare(dd->gclk);
 		dd->gclk_enabled = 0;
@@ -1033,6 +1016,7 @@ static int mchp_pdmc_probe(struct platform_device *pdev)
 	 */
 	dd->audio_filter_en = true;
 	dd->sinc_order = 3;
+	spin_lock_init(&dd->busy_lock);
 
 	dd->addr.addr = (dma_addr_t)res->start + MCHP_PDMC_RHR;
 	platform_set_drvdata(pdev, dd);
-- 
2.34.1


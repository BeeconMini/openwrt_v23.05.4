From df0fda628a4d58b273ae10b95fb9a542716b788e Mon Sep 17 00:00:00 2001
From: Cristian Birsan <cristian.birsan@microchip.com>
Date: Wed, 23 Feb 2022 22:47:35 +0200
Subject: [PATCH 309/471] usb: host: ohci-at91: add support for sama7g5 SoC

Add support for sama7g5 soc which requires an USB phy driver.

Signed-off-by: Cristian Birsan <cristian.birsan@microchip.com>
---
 drivers/usb/host/ohci-at91.c | 100 +++++++++++++++++++++++++++++------
 1 file changed, 84 insertions(+), 16 deletions(-)

diff --git a/drivers/usb/host/ohci-at91.c b/drivers/usb/host/ohci-at91.c
index a24aea3d2759..e35d516d5050 100644
--- a/drivers/usb/host/ohci-at91.c
+++ b/drivers/usb/host/ohci-at91.c
@@ -23,10 +23,12 @@
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/mfd/syscon.h>
+#include <linux/phy/phy.h>
 #include <linux/regmap.h>
 #include <linux/usb.h>
 #include <linux/usb/hcd.h>
 #include <soc/at91/atmel-sfr.h>
+#include <soc/at91/sama7-sfr.h>
 
 #include "ohci.h"
 
@@ -38,6 +40,12 @@
 #define hcd_to_ohci_at91_priv(h) \
 	((struct ohci_at91_priv *)hcd_to_ohci(h)->priv)
 
+struct at91_ohci_cfg {
+	unsigned int ohciicr;
+};
+
+static const struct of_device_id at91_ohci_dt_ids[];
+
 #define AT91_MAX_USBH_PORTS	3
 struct at91_usbh_data {
 	struct gpio_desc *vbus_pin[AT91_MAX_USBH_PORTS];
@@ -46,6 +54,7 @@ struct at91_usbh_data {
 	u8 overcurrent_supported;
 	u8 overcurrent_status[AT91_MAX_USBH_PORTS];
 	u8 overcurrent_changed[AT91_MAX_USBH_PORTS];
+	struct ohci_at91_priv *ohci_at91;
 };
 
 struct ohci_at91_priv {
@@ -55,6 +64,8 @@ struct ohci_at91_priv {
 	bool clocked;
 	bool wakeup;		/* Saved wake-up state for resume */
 	struct regmap *sfr_regmap;
+	const struct at91_ohci_cfg *cfg;
+	struct phy *phy[AT91_MAX_USBH_PORTS];
 };
 /* interface and function clocks; sometimes also an AHB clock */
 
@@ -72,9 +83,15 @@ static const struct ohci_driver_overrides ohci_at91_drv_overrides __initconst =
 
 static void at91_start_clock(struct ohci_at91_priv *ohci_at91)
 {
+	int i;
+
 	if (ohci_at91->clocked)
 		return;
 
+	at91_for_each_port(i) {
+		phy_power_on(ohci_at91->phy[i]);
+	}
+
 	clk_set_rate(ohci_at91->fclk, 48000000);
 	clk_prepare_enable(ohci_at91->hclk);
 	clk_prepare_enable(ohci_at91->iclk);
@@ -84,12 +101,19 @@ static void at91_start_clock(struct ohci_at91_priv *ohci_at91)
 
 static void at91_stop_clock(struct ohci_at91_priv *ohci_at91)
 {
+	int i;
+
 	if (!ohci_at91->clocked)
 		return;
 
 	clk_disable_unprepare(ohci_at91->fclk);
 	clk_disable_unprepare(ohci_at91->iclk);
 	clk_disable_unprepare(ohci_at91->hclk);
+
+	at91_for_each_port(i) {
+		phy_power_off(ohci_at91->phy[i]);
+	}
+
 	ohci_at91->clocked = false;
 }
 
@@ -140,11 +164,12 @@ static struct regmap *at91_dt_syscon_sfr(void)
 	struct regmap *regmap;
 
 	regmap = syscon_regmap_lookup_by_compatible("atmel,sama5d2-sfr");
-	if (IS_ERR(regmap)) {
+	if (IS_ERR(regmap))
 		regmap = syscon_regmap_lookup_by_compatible("microchip,sam9x60-sfr");
-		if (IS_ERR(regmap))
-			regmap = NULL;
-	}
+	if (IS_ERR(regmap))
+		regmap = syscon_regmap_lookup_by_compatible("microchip,sama7g5-sfr");
+	if (IS_ERR(regmap))
+		regmap = NULL;
 
 	return regmap;
 }
@@ -173,8 +198,10 @@ static int usb_hcd_at91_probe(const struct hc_driver *driver,
 	struct usb_hcd *hcd;
 	struct ohci_at91_priv *ohci_at91;
 	struct device *dev = &pdev->dev;
+	const struct of_device_id *match;
+	struct device_node *np = dev->of_node;
 	struct resource *res;
-	int irq;
+	int i, irq;
 
 	irq = platform_get_irq(pdev, 0);
 	if (irq < 0) {
@@ -196,6 +223,15 @@ static int usb_hcd_at91_probe(const struct hc_driver *driver,
 	hcd->rsrc_start = res->start;
 	hcd->rsrc_len = resource_size(res);
 
+	match = of_match_node(at91_ohci_dt_ids, np);
+	if (match && match->data) {
+		ohci_at91->cfg = match->data;
+	} else {
+		dev_err(dev, "failed to match compatible node\n");
+		retval = PTR_ERR(match);
+		goto err;
+	}
+
 	ohci_at91->iclk = devm_clk_get(dev, "ohci_clk");
 	if (IS_ERR(ohci_at91->iclk)) {
 		dev_err(dev, "failed to get ohci_clk\n");
@@ -219,7 +255,22 @@ static int usb_hcd_at91_probe(const struct hc_driver *driver,
 	if (!ohci_at91->sfr_regmap)
 		dev_dbg(dev, "failed to find sfr node\n");
 
+	at91_for_each_port(i) {
+		ohci_at91->phy[i] =  devm_of_phy_get_by_index(dev, np, i);
+
+		/* The phy is optional */
+		if (IS_ERR(ohci_at91->phy[i]) &&
+		   (PTR_ERR(ohci_at91->phy[i]) == -ENODEV)) {
+			dev_dbg(dev, "Optional PHY %d missing\n", i);
+			ohci_at91->phy[i] = NULL;
+		}
+
+		phy_init(ohci_at91->phy[i]);
+		phy_set_mode(ohci_at91->phy[i], PHY_MODE_USB_HOST);
+	}
+
 	board = hcd->self.controller->platform_data;
+	board->ohci_at91 = ohci_at91;
 	ohci = hcd_to_ohci(hcd);
 	ohci->num_ports = board->ports;
 	at91_start_hc(pdev);
@@ -303,15 +354,16 @@ static int ohci_at91_hub_status_data(struct usb_hcd *hcd, char *buf)
 	return length;
 }
 
-static int ohci_at91_port_suspend(struct regmap *regmap, u8 set)
+static int ohci_at91_port_suspend(struct ohci_at91_priv *ohci_at91, u8 set)
 {
 	u32 regval;
 	int ret;
+	struct regmap *regmap = ohci_at91->sfr_regmap;
 
 	if (!regmap)
 		return 0;
 
-	ret = regmap_read(regmap, AT91_SFR_OHCIICR, &regval);
+	ret = regmap_read(regmap, ohci_at91->cfg->ohciicr, &regval);
 	if (ret)
 		return ret;
 
@@ -320,7 +372,7 @@ static int ohci_at91_port_suspend(struct regmap *regmap, u8 set)
 	else
 		regval &= ~AT91_OHCIICR_USB_SUSPEND;
 
-	regmap_write(regmap, AT91_SFR_OHCIICR, regval);
+	regmap_write(regmap, ohci_at91->cfg->ohciicr, regval);
 
 	return 0;
 }
@@ -358,8 +410,7 @@ static int ohci_at91_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue,
 		case USB_PORT_FEAT_SUSPEND:
 			dev_dbg(hcd->self.controller, "SetPortFeat: SUSPEND\n");
 			if (valid_port(wIndex) && ohci_at91->sfr_regmap) {
-				ohci_at91_port_suspend(ohci_at91->sfr_regmap,
-						       1);
+				ohci_at91_port_suspend(ohci_at91, 1);
 				return 0;
 			}
 			break;
@@ -401,8 +452,7 @@ static int ohci_at91_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue,
 		case USB_PORT_FEAT_SUSPEND:
 			dev_dbg(hcd->self.controller, "ClearPortFeature: SUSPEND\n");
 			if (valid_port(wIndex) && ohci_at91->sfr_regmap) {
-				ohci_at91_port_suspend(ohci_at91->sfr_regmap,
-						       0);
+				ohci_at91_port_suspend(ohci_at91, 0);
 				return 0;
 			}
 			break;
@@ -501,8 +551,17 @@ static irqreturn_t ohci_hcd_at91_overcurrent_irq(int irq, void *data)
 	return IRQ_HANDLED;
 }
 
+static const struct at91_ohci_cfg at91rm9200_cfg = {
+	.ohciicr = AT91_SFR_OHCIICR,
+};
+
+static const struct at91_ohci_cfg sama7g5_cfg = {
+	.ohciicr = SAMA7_SFR_OHCIICR,
+};
+
 static const struct of_device_id at91_ohci_dt_ids[] = {
-	{ .compatible = "atmel,at91rm9200-ohci" },
+	{ .compatible = "atmel,at91rm9200-ohci", .data = &at91rm9200_cfg },
+	{ .compatible = "microchip,sama7g5-ohci", .data = &sama7g5_cfg },
 	{ /* sentinel */ }
 };
 
@@ -630,10 +689,10 @@ ohci_hcd_at91_drv_suspend(struct device *dev)
 		/* flush the writes */
 		(void) ohci_readl (ohci, &ohci->regs->control);
 		msleep(1);
-		ohci_at91_port_suspend(ohci_at91->sfr_regmap, 1);
+		ohci_at91_port_suspend(ohci_at91, 1);
 		at91_stop_clock(ohci_at91);
 	} else {
-		ohci_at91_port_suspend(ohci_at91->sfr_regmap, 1);
+		ohci_at91_port_suspend(ohci_at91, 1);
 	}
 
 	return ret;
@@ -644,8 +703,17 @@ ohci_hcd_at91_drv_resume(struct device *dev)
 {
 	struct usb_hcd	*hcd = dev_get_drvdata(dev);
 	struct ohci_at91_priv *ohci_at91 = hcd_to_ohci_at91_priv(hcd);
+	int i;
+
+	at91_for_each_port(i) {
+		if (!ohci_at91->phy[i])
+			continue;
+
+		phy_init(ohci_at91->phy[i]);
+		phy_set_mode(ohci_at91->phy[i], PHY_MODE_USB_HOST);
+	}
 
-	ohci_at91_port_suspend(ohci_at91->sfr_regmap, 0);
+	ohci_at91_port_suspend(ohci_at91, 0);
 
 	if (ohci_at91->wakeup)
 		disable_irq_wake(hcd->irq);
-- 
2.34.1


From b5ee345311720433208c023fc9b044ddb9b12dfe Mon Sep 17 00:00:00 2001
From: Eugen Hristev <eugen.hristev@microchip.com>
Date: Fri, 17 Dec 2021 15:23:14 +0200
Subject: [PATCH 242/471] media: platform: dwc: dw-csi-plat: implement media
 controller

Implement media controller, pad links, and the bound for the subdevice.
DWC platform has a subdevice sensor that is connected on the first port.
Implement the possibility to access this subdevice.
The subdevice must be connected asynchronously.
Implement the notifier to have this subdev connected.
Implement start streaming video ops for the subdevice.
Adapt the code to linux 5.15.

Signed-off-by: Eugen Hristev <eugen.hristev@microchip.com>
---
 drivers/media/platform/dwc/dw-csi-plat.c | 222 ++++++++++++++++-------
 drivers/media/platform/dwc/dw-mipi-csi.h |   6 +
 2 files changed, 166 insertions(+), 62 deletions(-)

diff --git a/drivers/media/platform/dwc/dw-csi-plat.c b/drivers/media/platform/dwc/dw-csi-plat.c
index d8934145f716..3563a47e7300 100644
--- a/drivers/media/platform/dwc/dw-csi-plat.c
+++ b/drivers/media/platform/dwc/dw-csi-plat.c
@@ -88,7 +88,7 @@ find_dw_mipi_csi_format(struct v4l2_mbus_framefmt *mf)
 }
 
 static int dw_mipi_csi_enum_mbus_code(struct v4l2_subdev *sd,
-				      struct v4l2_subdev_pad_config *cfg,
+					struct v4l2_subdev_state *sd_state,
 				      struct v4l2_subdev_mbus_code_enum *code)
 {
 	if (code->index >= ARRAY_SIZE(dw_mipi_csi_formats))
@@ -113,12 +113,12 @@ dw_mipi_csi_try_format(struct v4l2_mbus_framefmt *mf)
 }
 
 static struct v4l2_mbus_framefmt *
-dw_mipi_csi_get_format(struct dw_csi *dev, struct v4l2_subdev_pad_config *cfg,
+dw_mipi_csi_get_format(struct dw_csi *dev, struct v4l2_subdev_state *sd_state,
 		       enum v4l2_subdev_format_whence which)
 {
 	if (which == V4L2_SUBDEV_FORMAT_TRY)
-		return cfg ? v4l2_subdev_get_try_format(&dev->sd,
-							cfg,
+		return sd_state->pads ? v4l2_subdev_get_try_format(&dev->sd,
+							sd_state,
 							0) : NULL;
 	dev_dbg(dev->dev,
 		"%s got v4l2_mbus_pixelcode. 0x%x\n", __func__,
@@ -134,12 +134,12 @@ dw_mipi_csi_get_format(struct dw_csi *dev, struct v4l2_subdev_pad_config *cfg,
 
 static int
 dw_mipi_csi_set_fmt(struct v4l2_subdev *sd,
-		    struct v4l2_subdev_pad_config *cfg,
+struct v4l2_subdev_state *sd_state,
 		    struct v4l2_subdev_format *fmt)
 {
 	struct dw_csi *dev = sd_to_mipi_csi_dev(sd);
 	struct mipi_fmt *dev_fmt;
-	struct v4l2_mbus_framefmt *mf = dw_mipi_csi_get_format(dev, cfg,
+	struct v4l2_mbus_framefmt *mf = dw_mipi_csi_get_format(dev, sd_state,
 							       fmt->which);
 	int i;
 
@@ -172,13 +172,13 @@ dw_mipi_csi_set_fmt(struct v4l2_subdev *sd,
 
 static int
 dw_mipi_csi_get_fmt(struct v4l2_subdev *sd,
-		    struct v4l2_subdev_pad_config *cfg,
+struct v4l2_subdev_state *sd_state,
 		    struct v4l2_subdev_format *fmt)
 {
 	struct dw_csi *dev = sd_to_mipi_csi_dev(sd);
 	struct v4l2_mbus_framefmt *mf;
 
-	mf = dw_mipi_csi_get_format(dev, cfg, fmt->which);
+	mf = dw_mipi_csi_get_format(dev, sd_state, fmt->which);
 	if (!mf)
 		return -EINVAL;
 
@@ -188,26 +188,6 @@ dw_mipi_csi_get_fmt(struct v4l2_subdev *sd,
 
 	return 0;
 }
-
-static int
-dw_mipi_csi_s_power(struct v4l2_subdev *sd, int on)
-{
-	struct dw_csi *dev = sd_to_mipi_csi_dev(sd);
-
-	dev_vdbg(dev->dev, "%s: on=%d\n", __func__, on);
-
-	if (on) {
-		dw_mipi_csi_hw_stdby(dev);
-		dw_mipi_csi_start(dev);
-	} else {
-		phy_power_off(dev->phy);
-		dw_mipi_csi_mask_irq_power_off(dev);
-		/* reset data type */
-		dev->ipi_dt = 0x0;
-	}
-	return 0;
-}
-
 static int
 dw_mipi_csi_log_status(struct v4l2_subdev *sd)
 {
@@ -230,11 +210,12 @@ dw_mipi_csi_g_register(struct v4l2_subdev *sd, struct v4l2_dbg_register *reg)
 	return 0;
 }
 #endif
+
 static int dw_mipi_csi_init_cfg(struct v4l2_subdev *sd,
-				struct v4l2_subdev_pad_config *cfg)
+				struct v4l2_subdev_state *sd_state)
 {
 	struct v4l2_mbus_framefmt *format =
-	    v4l2_subdev_get_try_format(sd, cfg, 0);
+	    v4l2_subdev_get_try_format(sd, sd_state, 0);
 
 	format->colorspace = V4L2_COLORSPACE_SRGB;
 	format->code = MEDIA_BUS_FMT_RGB888_1X24;
@@ -243,8 +224,24 @@ static int dw_mipi_csi_init_cfg(struct v4l2_subdev *sd,
 	return 0;
 }
 
+static int dw_mipi_csi_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	struct dw_csi *dev = sd_to_mipi_csi_dev(sd);
+
+	if (enable) {
+		dw_mipi_csi_hw_stdby(dev);
+		dw_mipi_csi_start(dev);
+	}  else {
+		phy_power_off(dev->phy);
+		dw_mipi_csi_mask_irq_power_off(dev);
+		/* reset data type */
+		dev->ipi_dt = 0x0;
+	}
+
+	return v4l2_subdev_call(dev->input_sd, video, s_stream, enable);
+}
+
 static struct v4l2_subdev_core_ops dw_mipi_csi_core_ops = {
-	.s_power = dw_mipi_csi_s_power,
 	.log_status = dw_mipi_csi_log_status,
 #if IS_ENABLED(CONFIG_VIDEO_ADV_DEBUG)
 	.g_register = dw_mipi_csi_g_register,
@@ -262,17 +259,37 @@ static int dw_get_mbus_config(struct v4l2_subdev *sd, unsigned int pad,
 	return 0;
 }
 
+static int dw_enum_frame_size(struct v4l2_subdev *sd,
+				  struct v4l2_subdev_state *sd_state,
+				  struct v4l2_subdev_frame_size_enum *fse)
+{
+	if (fse->index) return -EINVAL;
+
+	fse->min_width = 16;
+	fse->max_width = 4000;
+	fse->min_height = 16;
+	fse->max_height =3000;
+
+	return 0;
+}
+
 static struct v4l2_subdev_pad_ops dw_mipi_csi_pad_ops = {
 	.init_cfg = dw_mipi_csi_init_cfg,
 	.enum_mbus_code = dw_mipi_csi_enum_mbus_code,
+	.enum_frame_size = dw_enum_frame_size,
 	.get_fmt = dw_mipi_csi_get_fmt,
 	.set_fmt = dw_mipi_csi_set_fmt,
 	.get_mbus_config = dw_get_mbus_config,
 };
 
+static struct v4l2_subdev_video_ops dw_mipi_csi_video_ops = {
+	.s_stream = dw_mipi_csi_s_stream,
+};
+
 static struct v4l2_subdev_ops dw_mipi_csi_subdev_ops = {
 	.core = &dw_mipi_csi_core_ops,
 	.pad = &dw_mipi_csi_pad_ops,
+	.video = &dw_mipi_csi_video_ops,
 };
 
 static irqreturn_t dw_mipi_csi_irq1(int irq, void *dev_id)
@@ -284,25 +301,71 @@ static irqreturn_t dw_mipi_csi_irq1(int irq, void *dev_id)
 	return IRQ_HANDLED;
 }
 
+static int dw_async_bound(struct v4l2_async_notifier *notifier,
+				 struct v4l2_subdev *subdev,
+				 struct v4l2_async_subdev *asd)
+{
+	struct dw_csi *dw = container_of(notifier,
+					struct dw_csi, notifier);
+	int ret;
+	int pad;
+
+	dev_dbg(dw->dev, "async bound\n");
+	dw->input_sd = subdev;
+
+	pad = media_entity_get_fwnode_pad(&subdev->entity,
+					      asd->match.fwnode,
+					      MEDIA_PAD_FL_SOURCE);
+	if (pad < 0) {
+		dev_err(dw->dev, "Failed to find pad for %s\n",
+			dw->sd.name);
+		return pad;
+	}
+
+	dw->remote_pad = pad;
+
+	ret = media_create_pad_link(&dw->input_sd->entity, dw->remote_pad,
+				    &dw->sd.entity, 0, MEDIA_LNK_FL_ENABLED );
+
+	if (ret < 0) {
+		dev_err(dw->dev,
+			 "Failed to create pad link: %s to %s\n",
+			 dw->input_sd->entity.name, dw->sd.entity.name);
+		return ret;
+	}
+
+	dev_dbg(dw->dev, "link with %s pad: %d\n",
+		 dw->input_sd->name, dw->remote_pad);
+
+	return ret;
+}
+
+static const struct v4l2_async_notifier_operations csi2host_async_ops = {
+        .bound = dw_async_bound,
+};
+
 static int
 dw_mipi_csi_parse_dt(struct platform_device *pdev, struct dw_csi *dev)
 {
-	struct device_node *node = pdev->dev.of_node;
+	struct device_node *node = pdev->dev.of_node, *input_node, *output_node,
+			   *input_parent;
 	struct v4l2_fwnode_endpoint ep = { .bus_type = V4L2_MBUS_CSI2_DPHY };
+	struct v4l2_fwnode_endpoint ep2 = { };
+	struct v4l2_async_subdev *asd;
 	int ret = 0;
 
 	if (of_property_read_u32(node, "snps,output-type",
 				 &dev->hw.output))
 		dev->hw.output = 2;
 
-	node = of_graph_get_next_endpoint(node, NULL);
-	if (!node) {
+	input_node = of_graph_get_next_endpoint(node, NULL);
+	if (!input_node) {
 		dev_err(&pdev->dev, "No port node at %pOF\n",
 			pdev->dev.of_node);
 		return -EINVAL;
 	}
 	/* Get port node and validate MIPI-CSI channel id. */
-	ret = v4l2_fwnode_endpoint_parse(of_fwnode_handle(node), &ep);
+	ret = v4l2_fwnode_endpoint_parse(of_fwnode_handle(input_node), &ep);
 	if (ret)
 		goto err;
 
@@ -312,6 +375,52 @@ dw_mipi_csi_parse_dt(struct platform_device *pdev, struct dw_csi *dev)
 		goto err;
 	}
 	dev->hw.num_lanes = ep.bus.mipi_csi2.num_data_lanes;
+
+	input_parent = of_graph_get_remote_port_parent(input_node);
+	if (!input_parent) {
+		dev_err(&pdev->dev, "could not get input node's parent node.\n");
+		return -EINVAL;
+	}
+
+	output_node = of_graph_get_next_endpoint(node, input_node);
+	if (!node) {
+		dev_err(&pdev->dev, "No port 2 node at %s\n",
+				pdev->dev.of_node->full_name);
+		return -EINVAL;
+	}
+	ret = v4l2_fwnode_endpoint_parse(of_fwnode_handle(output_node), &ep2);
+	if (ret)
+		goto err;
+
+	v4l2_async_notifier_init(&dev->notifier);
+
+        asd = v4l2_async_notifier_add_fwnode_remote_subdev(&dev->notifier,
+                                        of_fwnode_handle(input_node),
+                                        struct v4l2_async_subdev);
+
+	of_node_put(input_parent);
+
+	if (IS_ERR(asd)) {
+		ret = PTR_ERR(asd);
+		goto err;
+	}
+
+	if (ret) {
+		dev_err(&pdev->dev, "failed to add async notifier.\n");
+		goto csi2host_prepare_notifier_err;
+	}
+
+	dev->notifier.ops = &csi2host_async_ops;
+
+	ret = v4l2_async_subdev_notifier_register(&dev->sd, &dev->notifier);
+
+	if (ret) {
+		dev_err(&pdev->dev, "fail to register async notifier.\n");
+		goto csi2host_prepare_notifier_err;
+	}
+
+csi2host_prepare_notifier_err:
+	of_node_put(input_parent);
 err:
 	of_node_put(node);
 	return ret;
@@ -332,7 +441,7 @@ static int dw_csi_probe(struct platform_device *pdev)
 	if (!IS_ENABLED(CONFIG_OF))
 		pdata = pdev->dev.platform_data;
 
-	dev_vdbg(dev, "Probing started\n");
+	dev_dbg(dev, "Probing started\n");
 
 	/* Resource allocation */
 	csi = devm_kzalloc(dev, sizeof(*csi), GFP_KERNEL);
@@ -369,14 +478,6 @@ static int dw_csi_probe(struct platform_device *pdev)
 		goto csi2host_phyclk_err;
 	}
 
-	ret = v4l2_device_register(&pdev->dev, &csi->v4l2_dev);
-	if (ret) {
-		dev_err(dev, "failed to register v4l2 device\n");
-		goto csi2host_reg_err;
-	}
-
-	dev_vdbg(dev, "v4l2.name: %s\n", csi->v4l2_dev.name);
-
 	if (dev->of_node) {
 		of_id = of_match_node(dw_mipi_csi_of_match, dev->of_node);
 		if (!of_id) {
@@ -390,8 +491,9 @@ static int dw_csi_probe(struct platform_device *pdev)
 
 		csi->phy = devm_of_phy_get(dev, dev->of_node, NULL);
 		if (IS_ERR(csi->phy)) {
-			dev_err(dev, "No DPHY available\n");
-			return PTR_ERR(csi->phy);
+			dev_dbg(dev, "No DPHY available\n");
+			ret = -EPROBE_DEFER; /* attempt to defer */
+			goto csi2host_defer_err;
 		}
 	} else {
 		csi->phy = devm_phy_get(dev, phys[pdata->id].name);
@@ -446,6 +548,7 @@ static int dw_csi_probe(struct platform_device *pdev)
 	sd = &csi->sd;
 	v4l2_subdev_init(sd, &dw_mipi_csi_subdev_ops);
 	csi->sd.owner = THIS_MODULE;
+	csi->sd.fwnode = of_fwnode_handle(dev->of_node);
 
 	if (dev->of_node) {
 		snprintf(sd->name, sizeof(sd->name), "%s.%d",
@@ -454,13 +557,11 @@ static int dw_csi_probe(struct platform_device *pdev)
 		csi->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
 	} else {
 		strlcpy(sd->name, dev_name(dev), sizeof(sd->name));
-		strlcpy(csi->v4l2_dev.name, dev_name(dev),
-			sizeof(csi->v4l2_dev.name));
 	}
 	csi->fmt = &dw_mipi_csi_formats[0];
 	csi->format.code = dw_mipi_csi_formats[0].mbus_code;
 
-	sd->entity.function = MEDIA_ENT_F_IO_V4L;
+	sd->entity.function = MEDIA_ENT_F_VID_IF_BRIDGE;
 
 	if (dev->of_node) {
 		csi->pads[CSI_PAD_SINK].flags = MEDIA_PAD_FL_SINK;
@@ -477,15 +578,7 @@ static int dw_csi_probe(struct platform_device *pdev)
 		csi->hw.pclk = pdata->pclk;
 		csi->hw.fps = pdata->fps;
 		csi->hw.dphy_freq = pdata->hs_freq;
-
-		ret = v4l2_device_register(NULL, &csi->v4l2_dev);
-		if (ret) {
-			dev_err(dev, "failed to register v4l2 device\n");
-			goto end;
-		}
 	}
-	dev_vdbg(dev, "v4l2.name: %s\n", csi->v4l2_dev.name);
-
 	v4l2_set_subdevdata(&csi->sd, pdev);
 	platform_set_drvdata(pdev, &csi->sd);
 	dev_set_drvdata(dev, sd);
@@ -505,13 +598,19 @@ static int dw_csi_probe(struct platform_device *pdev)
 
 	phy_init(csi->phy);
 
-	return 0;
+	ret = v4l2_async_register_subdev(&csi->sd);
+
+	if (ret)
+		dev_dbg(csi->dev, "failed to register the subdevice\n");
+
+	return ret;
 end:
 #if IS_ENABLED(CONFIG_OF)
 	media_entity_cleanup(&csi->sd.entity);
-	return ret;
 #endif
-	v4l2_device_unregister(csi->vdev.v4l2_dev);
+csi2host_defer_err:
+	v4l2_async_notifier_unregister(&csi->notifier);
+	v4l2_async_notifier_cleanup(&csi->notifier);
 
 csi2host_reg_err:
 	clk_disable_unprepare(csi->phyclk);
@@ -536,9 +635,8 @@ static int dw_csi_remove(struct platform_device *pdev)
 		reset_control_assert(mipi_csi->rst);
 #if IS_ENABLED(CONFIG_OF)
 	media_entity_cleanup(&mipi_csi->sd.entity);
-#else
-	v4l2_device_unregister(mipi_csi->vdev.v4l2_dev);
 #endif
+
 	return 0;
 }
 
diff --git a/drivers/media/platform/dwc/dw-mipi-csi.h b/drivers/media/platform/dwc/dw-mipi-csi.h
index bbc35490e2b6..e4420ee16753 100644
--- a/drivers/media/platform/dwc/dw-mipi-csi.h
+++ b/drivers/media/platform/dwc/dw-mipi-csi.h
@@ -251,6 +251,12 @@ struct dw_csi {
 	u8 index;
 	u8 hw_version_major;
 	u16 hw_version_minor;
+
+	struct v4l2_async_notifier notifier;
+
+	u32 remote_pad;
+
+	struct v4l2_subdev *input_sd;
 };
 
 static inline struct dw_csi *sd_to_mipi_csi_dev(struct v4l2_subdev *sdev)
-- 
2.34.1

